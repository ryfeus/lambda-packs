// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/caffe2.proto

#ifndef PROTOBUF_caffe2_2fproto_2fcaffe2_2eproto__INCLUDED
#define PROTOBUF_caffe2_2fproto_2fcaffe2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_caffe2_2fproto_2fcaffe2_2eproto {
// Internal implementation detail -- do not use these members.
struct CAFFE2_API TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void CAFFE2_API AddDescriptors();
void CAFFE2_API InitDefaultsExternalDataProtoImpl();
void CAFFE2_API InitDefaultsExternalDataProto();
void CAFFE2_API InitDefaultsTensorProto_SegmentImpl();
void CAFFE2_API InitDefaultsTensorProto_Segment();
void CAFFE2_API InitDefaultsTensorProtoImpl();
void CAFFE2_API InitDefaultsTensorProto();
void CAFFE2_API InitDefaultsQTensorProtoImpl();
void CAFFE2_API InitDefaultsQTensorProto();
void CAFFE2_API InitDefaultsTensorProtosImpl();
void CAFFE2_API InitDefaultsTensorProtos();
void CAFFE2_API InitDefaultsTensorShapeImpl();
void CAFFE2_API InitDefaultsTensorShape();
void CAFFE2_API InitDefaultsTensorShapesImpl();
void CAFFE2_API InitDefaultsTensorShapes();
void CAFFE2_API InitDefaultsArgumentImpl();
void CAFFE2_API InitDefaultsArgument();
void CAFFE2_API InitDefaultsDeviceOptionImpl();
void CAFFE2_API InitDefaultsDeviceOption();
void CAFFE2_API InitDefaultsExecutionStepImpl();
void CAFFE2_API InitDefaultsExecutionStep();
void CAFFE2_API InitDefaultsPlanDefImpl();
void CAFFE2_API InitDefaultsPlanDef();
void CAFFE2_API InitDefaultsBlobProtoImpl();
void CAFFE2_API InitDefaultsBlobProto();
void CAFFE2_API InitDefaultsDBReaderProtoImpl();
void CAFFE2_API InitDefaultsDBReaderProto();
inline void CAFFE2_API InitDefaults() {
  InitDefaultsExternalDataProto();
  InitDefaultsTensorProto_Segment();
  InitDefaultsTensorProto();
  InitDefaultsQTensorProto();
  InitDefaultsTensorProtos();
  InitDefaultsTensorShape();
  InitDefaultsTensorShapes();
  InitDefaultsArgument();
  InitDefaultsDeviceOption();
  InitDefaultsExecutionStep();
  InitDefaultsPlanDef();
  InitDefaultsBlobProto();
  InitDefaultsDBReaderProto();
}
}  // namespace protobuf_caffe2_2fproto_2fcaffe2_2eproto
namespace caffe2 { const ::std::string& GetEmptyStringAlreadyInited(); 
class Argument;
class ArgumentDefaultTypeInternal;
CAFFE2_API extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class BlobProto;
class BlobProtoDefaultTypeInternal;
CAFFE2_API extern BlobProtoDefaultTypeInternal _BlobProto_default_instance_;
class DBReaderProto;
class DBReaderProtoDefaultTypeInternal;
CAFFE2_API extern DBReaderProtoDefaultTypeInternal _DBReaderProto_default_instance_;
class DeviceOption;
class DeviceOptionDefaultTypeInternal;
CAFFE2_API extern DeviceOptionDefaultTypeInternal _DeviceOption_default_instance_;
class ExecutionStep;
class ExecutionStepDefaultTypeInternal;
CAFFE2_API extern ExecutionStepDefaultTypeInternal _ExecutionStep_default_instance_;
class ExternalDataProto;
class ExternalDataProtoDefaultTypeInternal;
CAFFE2_API extern ExternalDataProtoDefaultTypeInternal _ExternalDataProto_default_instance_;
class NetDef;
class NetDefDefaultTypeInternal;
CAFFE2_API extern NetDefDefaultTypeInternal _NetDef_default_instance_;
class OperatorDef;
class OperatorDefDefaultTypeInternal;
CAFFE2_API extern OperatorDefDefaultTypeInternal _OperatorDef_default_instance_;
class PlanDef;
class PlanDefDefaultTypeInternal;
CAFFE2_API extern PlanDefDefaultTypeInternal _PlanDef_default_instance_;
class QTensorProto;
class QTensorProtoDefaultTypeInternal;
CAFFE2_API extern QTensorProtoDefaultTypeInternal _QTensorProto_default_instance_;
class TensorProto;
class TensorProtoDefaultTypeInternal;
CAFFE2_API extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
class TensorProto_Segment;
class TensorProto_SegmentDefaultTypeInternal;
CAFFE2_API extern TensorProto_SegmentDefaultTypeInternal _TensorProto_Segment_default_instance_;
class TensorProtos;
class TensorProtosDefaultTypeInternal;
CAFFE2_API extern TensorProtosDefaultTypeInternal _TensorProtos_default_instance_;
class TensorShape;
class TensorShapeDefaultTypeInternal;
CAFFE2_API extern TensorShapeDefaultTypeInternal _TensorShape_default_instance_;
class TensorShapes;
class TensorShapesDefaultTypeInternal;
CAFFE2_API extern TensorShapesDefaultTypeInternal _TensorShapes_default_instance_;
}  // namespace caffe2
namespace caffe2 {

enum ExternalDataProto_SourceType {
  ExternalDataProto_SourceType_INLINE_CONTAINER = 0,
  ExternalDataProto_SourceType_SIMPLE_FILE = 1
};
CAFFE2_API bool ExternalDataProto_SourceType_IsValid(int value);
const ExternalDataProto_SourceType ExternalDataProto_SourceType_SourceType_MIN = ExternalDataProto_SourceType_INLINE_CONTAINER;
const ExternalDataProto_SourceType ExternalDataProto_SourceType_SourceType_MAX = ExternalDataProto_SourceType_SIMPLE_FILE;
const int ExternalDataProto_SourceType_SourceType_ARRAYSIZE = ExternalDataProto_SourceType_SourceType_MAX + 1;

CAFFE2_API const ::google::protobuf::EnumDescriptor* ExternalDataProto_SourceType_descriptor();
inline const ::std::string& ExternalDataProto_SourceType_Name(ExternalDataProto_SourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalDataProto_SourceType_descriptor(), value);
}
inline bool ExternalDataProto_SourceType_Parse(
    const ::std::string& name, ExternalDataProto_SourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalDataProto_SourceType>(
    ExternalDataProto_SourceType_descriptor(), name, value);
}
enum TensorProto_DataType {
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_INT32 = 2,
  TensorProto_DataType_BYTE = 3,
  TensorProto_DataType_STRING = 4,
  TensorProto_DataType_BOOL = 5,
  TensorProto_DataType_UINT8 = 6,
  TensorProto_DataType_INT8 = 7,
  TensorProto_DataType_UINT16 = 8,
  TensorProto_DataType_INT16 = 9,
  TensorProto_DataType_INT64 = 10,
  TensorProto_DataType_FLOAT16 = 12,
  TensorProto_DataType_DOUBLE = 13
};
CAFFE2_API bool TensorProto_DataType_IsValid(int value);
const TensorProto_DataType TensorProto_DataType_DataType_MIN = TensorProto_DataType_UNDEFINED;
const TensorProto_DataType TensorProto_DataType_DataType_MAX = TensorProto_DataType_DOUBLE;
const int TensorProto_DataType_DataType_ARRAYSIZE = TensorProto_DataType_DataType_MAX + 1;

CAFFE2_API const ::google::protobuf::EnumDescriptor* TensorProto_DataType_descriptor();
inline const ::std::string& TensorProto_DataType_Name(TensorProto_DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TensorProto_DataType_descriptor(), value);
}
inline bool TensorProto_DataType_Parse(
    const ::std::string& name, TensorProto_DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TensorProto_DataType>(
    TensorProto_DataType_descriptor(), name, value);
}
enum TensorProto_StorageType {
  TensorProto_StorageType_TYPED = 1,
  TensorProto_StorageType_RAW = 2,
  TensorProto_StorageType_EXTERNAL = 3,
  TensorProto_StorageType_NO_CONTENT = 4
};
CAFFE2_API bool TensorProto_StorageType_IsValid(int value);
const TensorProto_StorageType TensorProto_StorageType_StorageType_MIN = TensorProto_StorageType_TYPED;
const TensorProto_StorageType TensorProto_StorageType_StorageType_MAX = TensorProto_StorageType_NO_CONTENT;
const int TensorProto_StorageType_StorageType_ARRAYSIZE = TensorProto_StorageType_StorageType_MAX + 1;

CAFFE2_API const ::google::protobuf::EnumDescriptor* TensorProto_StorageType_descriptor();
inline const ::std::string& TensorProto_StorageType_Name(TensorProto_StorageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TensorProto_StorageType_descriptor(), value);
}
inline bool TensorProto_StorageType_Parse(
    const ::std::string& name, TensorProto_StorageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TensorProto_StorageType>(
    TensorProto_StorageType_descriptor(), name, value);
}
enum DeviceTypeProto {
  PROTO_CPU = 0,
  PROTO_CUDA = 1,
  PROTO_MKLDNN = 2,
  PROTO_OPENGL = 3,
  PROTO_OPENCL = 4,
  PROTO_IDEEP = 5,
  PROTO_HIP = 6,
  PROTO_FPGA = 7,
  PROTO_COMPILE_TIME_MAX_DEVICE_TYPES = 8,
  PROTO_ONLY_FOR_TEST = 20901
};
CAFFE2_API bool DeviceTypeProto_IsValid(int value);
const DeviceTypeProto DeviceTypeProto_MIN = PROTO_CPU;
const DeviceTypeProto DeviceTypeProto_MAX = PROTO_ONLY_FOR_TEST;
const int DeviceTypeProto_ARRAYSIZE = DeviceTypeProto_MAX + 1;

CAFFE2_API const ::google::protobuf::EnumDescriptor* DeviceTypeProto_descriptor();
inline const ::std::string& DeviceTypeProto_Name(DeviceTypeProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceTypeProto_descriptor(), value);
}
inline bool DeviceTypeProto_Parse(
    const ::std::string& name, DeviceTypeProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceTypeProto>(
    DeviceTypeProto_descriptor(), name, value);
}
// ===================================================================

class CAFFE2_API ExternalDataProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.ExternalDataProto) */ {
 public:
  ExternalDataProto();
  virtual ~ExternalDataProto();

  ExternalDataProto(const ExternalDataProto& from);

  inline ExternalDataProto& operator=(const ExternalDataProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExternalDataProto(ExternalDataProto&& from) noexcept
    : ExternalDataProto() {
    *this = ::std::move(from);
  }

  inline ExternalDataProto& operator=(ExternalDataProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalDataProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternalDataProto* internal_default_instance() {
    return reinterpret_cast<const ExternalDataProto*>(
               &_ExternalDataProto_default_instance_);
  }
  static  int const kIndexInFileMessages =
    0;

  void Swap(ExternalDataProto* other);
  friend void swap(ExternalDataProto& a, ExternalDataProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExternalDataProto* New() const PROTOBUF_FINAL { return New(NULL); }

  ExternalDataProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExternalDataProto& from);
  void MergeFrom(const ExternalDataProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExternalDataProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ExternalDataProto_SourceType SourceType;
  static const SourceType INLINE_CONTAINER =
    ExternalDataProto_SourceType_INLINE_CONTAINER;
  static const SourceType SIMPLE_FILE =
    ExternalDataProto_SourceType_SIMPLE_FILE;
  static inline bool SourceType_IsValid(int value) {
    return ExternalDataProto_SourceType_IsValid(value);
  }
  static const SourceType SourceType_MIN =
    ExternalDataProto_SourceType_SourceType_MIN;
  static const SourceType SourceType_MAX =
    ExternalDataProto_SourceType_SourceType_MAX;
  static const int SourceType_ARRAYSIZE =
    ExternalDataProto_SourceType_SourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SourceType_descriptor() {
    return ExternalDataProto_SourceType_descriptor();
  }
  static inline const ::std::string& SourceType_Name(SourceType value) {
    return ExternalDataProto_SourceType_Name(value);
  }
  static inline bool SourceType_Parse(const ::std::string& name,
      SourceType* value) {
    return ExternalDataProto_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int64 strides = 4;
  int strides_size() const;
  void clear_strides();
  static const int kStridesFieldNumber = 4;
  ::google::protobuf::int64 strides(int index) const;
  void set_strides(int index, ::google::protobuf::int64 value);
  void add_strides(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      strides() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_strides();

  // optional string record_id = 2;
  bool has_record_id() const;
  void clear_record_id();
  static const int kRecordIdFieldNumber = 2;
  const ::std::string& record_id() const;
  void set_record_id(const ::std::string& value);
  #if LANG_CXX11
  void set_record_id(::std::string&& value);
  #endif
  void set_record_id(const char* value);
  void set_record_id(const char* value, size_t size);
  ::std::string* mutable_record_id();
  ::std::string* release_record_id();
  void set_allocated_record_id(::std::string* record_id);

  // optional int64 offset = 3 [default = 0];
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // optional uint64 record_size = 5;
  bool has_record_size() const;
  void clear_record_size();
  static const int kRecordSizeFieldNumber = 5;
  ::google::protobuf::uint64 record_size() const;
  void set_record_size(::google::protobuf::uint64 value);

  // optional .caffe2.ExternalDataProto.SourceType source_type = 1 [default = INLINE_CONTAINER];
  bool has_source_type() const;
  void clear_source_type();
  static const int kSourceTypeFieldNumber = 1;
  ::caffe2::ExternalDataProto_SourceType source_type() const;
  void set_source_type(::caffe2::ExternalDataProto_SourceType value);

  // @@protoc_insertion_point(class_scope:caffe2.ExternalDataProto)
 private:
  void set_has_source_type();
  void clear_has_source_type();
  void set_has_record_id();
  void clear_has_record_id();
  void set_has_record_size();
  void clear_has_record_size();
  void set_has_offset();
  void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > strides_;
  ::google::protobuf::internal::ArenaStringPtr record_id_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::uint64 record_size_;
  int source_type_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsExternalDataProtoImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API TensorProto_Segment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorProto.Segment) */ {
 public:
  TensorProto_Segment();
  virtual ~TensorProto_Segment();

  TensorProto_Segment(const TensorProto_Segment& from);

  inline TensorProto_Segment& operator=(const TensorProto_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorProto_Segment(TensorProto_Segment&& from) noexcept
    : TensorProto_Segment() {
    *this = ::std::move(from);
  }

  inline TensorProto_Segment& operator=(TensorProto_Segment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorProto_Segment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProto_Segment* internal_default_instance() {
    return reinterpret_cast<const TensorProto_Segment*>(
               &_TensorProto_Segment_default_instance_);
  }
  static  int const kIndexInFileMessages =
    1;

  void Swap(TensorProto_Segment* other);
  friend void swap(TensorProto_Segment& a, TensorProto_Segment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorProto_Segment* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorProto_Segment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorProto_Segment& from);
  void MergeFrom(const TensorProto_Segment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorProto_Segment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 begin = 1;
  bool has_begin() const;
  void clear_begin();
  static const int kBeginFieldNumber = 1;
  ::google::protobuf::int64 begin() const;
  void set_begin(::google::protobuf::int64 value);

  // required int64 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int64 end() const;
  void set_end(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:caffe2.TensorProto.Segment)
 private:
  void set_has_begin();
  void clear_has_begin();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 begin_;
  ::google::protobuf::int64 end_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsTensorProto_SegmentImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API TensorProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorProto) */ {
 public:
  TensorProto();
  virtual ~TensorProto();

  TensorProto(const TensorProto& from);

  inline TensorProto& operator=(const TensorProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorProto(TensorProto&& from) noexcept
    : TensorProto() {
    *this = ::std::move(from);
  }

  inline TensorProto& operator=(TensorProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProto* internal_default_instance() {
    return reinterpret_cast<const TensorProto*>(
               &_TensorProto_default_instance_);
  }
  static  int const kIndexInFileMessages =
    2;

  void Swap(TensorProto* other);
  friend void swap(TensorProto& a, TensorProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorProto* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorProto& from);
  void MergeFrom(const TensorProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TensorProto_Segment Segment;

  typedef TensorProto_DataType DataType;
  static const DataType UNDEFINED =
    TensorProto_DataType_UNDEFINED;
  static const DataType FLOAT =
    TensorProto_DataType_FLOAT;
  static const DataType INT32 =
    TensorProto_DataType_INT32;
  static const DataType BYTE =
    TensorProto_DataType_BYTE;
  static const DataType STRING =
    TensorProto_DataType_STRING;
  static const DataType BOOL =
    TensorProto_DataType_BOOL;
  static const DataType UINT8 =
    TensorProto_DataType_UINT8;
  static const DataType INT8 =
    TensorProto_DataType_INT8;
  static const DataType UINT16 =
    TensorProto_DataType_UINT16;
  static const DataType INT16 =
    TensorProto_DataType_INT16;
  static const DataType INT64 =
    TensorProto_DataType_INT64;
  static const DataType FLOAT16 =
    TensorProto_DataType_FLOAT16;
  static const DataType DOUBLE =
    TensorProto_DataType_DOUBLE;
  static inline bool DataType_IsValid(int value) {
    return TensorProto_DataType_IsValid(value);
  }
  static const DataType DataType_MIN =
    TensorProto_DataType_DataType_MIN;
  static const DataType DataType_MAX =
    TensorProto_DataType_DataType_MAX;
  static const int DataType_ARRAYSIZE =
    TensorProto_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataType_descriptor() {
    return TensorProto_DataType_descriptor();
  }
  static inline const ::std::string& DataType_Name(DataType value) {
    return TensorProto_DataType_Name(value);
  }
  static inline bool DataType_Parse(const ::std::string& name,
      DataType* value) {
    return TensorProto_DataType_Parse(name, value);
  }

  typedef TensorProto_StorageType StorageType;
  static const StorageType TYPED =
    TensorProto_StorageType_TYPED;
  static const StorageType RAW =
    TensorProto_StorageType_RAW;
  static const StorageType EXTERNAL =
    TensorProto_StorageType_EXTERNAL;
  static const StorageType NO_CONTENT =
    TensorProto_StorageType_NO_CONTENT;
  static inline bool StorageType_IsValid(int value) {
    return TensorProto_StorageType_IsValid(value);
  }
  static const StorageType StorageType_MIN =
    TensorProto_StorageType_StorageType_MIN;
  static const StorageType StorageType_MAX =
    TensorProto_StorageType_StorageType_MAX;
  static const int StorageType_ARRAYSIZE =
    TensorProto_StorageType_StorageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StorageType_descriptor() {
    return TensorProto_StorageType_descriptor();
  }
  static inline const ::std::string& StorageType_Name(StorageType value) {
    return TensorProto_StorageType_Name(value);
  }
  static inline bool StorageType_Parse(const ::std::string& name,
      StorageType* value) {
    return TensorProto_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // repeated float float_data = 3 [packed = true];
  int float_data_size() const;
  void clear_float_data();
  static const int kFloatDataFieldNumber = 3;
  float float_data(int index) const;
  void set_float_data(int index, float value);
  void add_float_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      float_data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_float_data();

  // repeated int32 int32_data = 4 [packed = true];
  int int32_data_size() const;
  void clear_int32_data();
  static const int kInt32DataFieldNumber = 4;
  ::google::protobuf::int32 int32_data(int index) const;
  void set_int32_data(int index, ::google::protobuf::int32 value);
  void add_int32_data(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      int32_data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_int32_data();

  // repeated bytes string_data = 6;
  int string_data_size() const;
  void clear_string_data();
  static const int kStringDataFieldNumber = 6;
  const ::std::string& string_data(int index) const;
  ::std::string* mutable_string_data(int index);
  void set_string_data(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_string_data(int index, ::std::string&& value);
  #endif
  void set_string_data(int index, const char* value);
  void set_string_data(int index, const void* value, size_t size);
  ::std::string* add_string_data();
  void add_string_data(const ::std::string& value);
  #if LANG_CXX11
  void add_string_data(::std::string&& value);
  #endif
  void add_string_data(const char* value);
  void add_string_data(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& string_data() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_data();

  // repeated double double_data = 9 [packed = true];
  int double_data_size() const;
  void clear_double_data();
  static const int kDoubleDataFieldNumber = 9;
  double double_data(int index) const;
  void set_double_data(int index, double value);
  void add_double_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      double_data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_double_data();

  // repeated int64 int64_data = 10 [packed = true];
  int int64_data_size() const;
  void clear_int64_data();
  static const int kInt64DataFieldNumber = 10;
  ::google::protobuf::int64 int64_data(int index) const;
  void set_int64_data(int index, ::google::protobuf::int64 value);
  void add_int64_data(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      int64_data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_int64_data();

  // optional bytes byte_data = 5;
  bool has_byte_data() const;
  void clear_byte_data();
  static const int kByteDataFieldNumber = 5;
  const ::std::string& byte_data() const;
  void set_byte_data(const ::std::string& value);
  #if LANG_CXX11
  void set_byte_data(::std::string&& value);
  #endif
  void set_byte_data(const char* value);
  void set_byte_data(const void* value, size_t size);
  ::std::string* mutable_byte_data();
  ::std::string* release_byte_data();
  void set_allocated_byte_data(::std::string* byte_data);

  // optional string name = 7;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 7;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes raw_data = 13;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 13;
  const ::std::string& raw_data() const;
  void set_raw_data(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_data(::std::string&& value);
  #endif
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  ::std::string* mutable_raw_data();
  ::std::string* release_raw_data();
  void set_allocated_raw_data(::std::string* raw_data);

  // optional .caffe2.DeviceOption device_detail = 8;
  bool has_device_detail() const;
  void clear_device_detail();
  static const int kDeviceDetailFieldNumber = 8;
  const ::caffe2::DeviceOption& device_detail() const;
  ::caffe2::DeviceOption* release_device_detail();
  ::caffe2::DeviceOption* mutable_device_detail();
  void set_allocated_device_detail(::caffe2::DeviceOption* device_detail);

  // optional .caffe2.TensorProto.Segment segment = 11;
  bool has_segment() const;
  void clear_segment();
  static const int kSegmentFieldNumber = 11;
  const ::caffe2::TensorProto_Segment& segment() const;
  ::caffe2::TensorProto_Segment* release_segment();
  ::caffe2::TensorProto_Segment* mutable_segment();
  void set_allocated_segment(::caffe2::TensorProto_Segment* segment);

  // optional .caffe2.ExternalDataProto external_data = 14;
  bool has_external_data() const;
  void clear_external_data();
  static const int kExternalDataFieldNumber = 14;
  const ::caffe2::ExternalDataProto& external_data() const;
  ::caffe2::ExternalDataProto* release_external_data();
  ::caffe2::ExternalDataProto* mutable_external_data();
  void set_allocated_external_data(::caffe2::ExternalDataProto* external_data);

  // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);

  // optional .caffe2.TensorProto.StorageType storage_type = 12 [default = TYPED];
  bool has_storage_type() const;
  void clear_storage_type();
  static const int kStorageTypeFieldNumber = 12;
  ::caffe2::TensorProto_StorageType storage_type() const;
  void set_storage_type(::caffe2::TensorProto_StorageType value);

  // @@protoc_insertion_point(class_scope:caffe2.TensorProto)
 private:
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_storage_type();
  void clear_has_storage_type();
  void set_has_byte_data();
  void clear_has_byte_data();
  void set_has_raw_data();
  void clear_has_raw_data();
  void set_has_external_data();
  void clear_has_external_data();
  void set_has_name();
  void clear_has_name();
  void set_has_device_detail();
  void clear_has_device_detail();
  void set_has_segment();
  void clear_has_segment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  ::google::protobuf::RepeatedField< float > float_data_;
  mutable int _float_data_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > int32_data_;
  mutable int _int32_data_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_data_;
  ::google::protobuf::RepeatedField< double > double_data_;
  mutable int _double_data_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > int64_data_;
  mutable int _int64_data_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr byte_data_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr raw_data_;
  ::caffe2::DeviceOption* device_detail_;
  ::caffe2::TensorProto_Segment* segment_;
  ::caffe2::ExternalDataProto* external_data_;
  int data_type_;
  int storage_type_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsTensorProtoImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API QTensorProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.QTensorProto) */ {
 public:
  QTensorProto();
  virtual ~QTensorProto();

  QTensorProto(const QTensorProto& from);

  inline QTensorProto& operator=(const QTensorProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QTensorProto(QTensorProto&& from) noexcept
    : QTensorProto() {
    *this = ::std::move(from);
  }

  inline QTensorProto& operator=(QTensorProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QTensorProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QTensorProto* internal_default_instance() {
    return reinterpret_cast<const QTensorProto*>(
               &_QTensorProto_default_instance_);
  }
  static  int const kIndexInFileMessages =
    3;

  void Swap(QTensorProto* other);
  friend void swap(QTensorProto& a, QTensorProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QTensorProto* New() const PROTOBUF_FINAL { return New(NULL); }

  QTensorProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QTensorProto& from);
  void MergeFrom(const QTensorProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QTensorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // repeated int32 data = 6 [packed = true];
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  ::google::protobuf::int32 data(int index) const;
  void set_data(int index, ::google::protobuf::int32 value);
  void add_data(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // optional string name = 7;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 7;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required double scale = 3;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 3;
  double scale() const;
  void set_scale(double value);

  // required int32 precision = 2;
  bool has_precision() const;
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // required bool is_signed = 5;
  bool has_is_signed() const;
  void clear_is_signed();
  static const int kIsSignedFieldNumber = 5;
  bool is_signed() const;
  void set_is_signed(bool value);

  // required double bias = 4;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 4;
  double bias() const;
  void set_bias(double value);

  // optional .caffe2.TensorProto.DataType data_type = 8 [default = INT32];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 8;
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);

  // @@protoc_insertion_point(class_scope:caffe2.QTensorProto)
 private:
  void set_has_precision();
  void clear_has_precision();
  void set_has_scale();
  void clear_has_scale();
  void set_has_bias();
  void clear_has_bias();
  void set_has_is_signed();
  void clear_has_is_signed();
  void set_has_name();
  void clear_has_name();
  void set_has_data_type();
  void clear_has_data_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double scale_;
  ::google::protobuf::int32 precision_;
  bool is_signed_;
  double bias_;
  int data_type_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsQTensorProtoImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API TensorProtos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorProtos) */ {
 public:
  TensorProtos();
  virtual ~TensorProtos();

  TensorProtos(const TensorProtos& from);

  inline TensorProtos& operator=(const TensorProtos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorProtos(TensorProtos&& from) noexcept
    : TensorProtos() {
    *this = ::std::move(from);
  }

  inline TensorProtos& operator=(TensorProtos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorProtos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProtos* internal_default_instance() {
    return reinterpret_cast<const TensorProtos*>(
               &_TensorProtos_default_instance_);
  }
  static  int const kIndexInFileMessages =
    4;

  void Swap(TensorProtos* other);
  friend void swap(TensorProtos& a, TensorProtos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorProtos* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorProtos* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorProtos& from);
  void MergeFrom(const TensorProtos& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorProtos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.TensorProto protos = 1;
  int protos_size() const;
  void clear_protos();
  static const int kProtosFieldNumber = 1;
  const ::caffe2::TensorProto& protos(int index) const;
  ::caffe2::TensorProto* mutable_protos(int index);
  ::caffe2::TensorProto* add_protos();
  ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >*
      mutable_protos();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >&
      protos() const;

  // @@protoc_insertion_point(class_scope:caffe2.TensorProtos)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto > protos_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsTensorProtosImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API TensorShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorShape) */ {
 public:
  TensorShape();
  virtual ~TensorShape();

  TensorShape(const TensorShape& from);

  inline TensorShape& operator=(const TensorShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorShape(TensorShape&& from) noexcept
    : TensorShape() {
    *this = ::std::move(from);
  }

  inline TensorShape& operator=(TensorShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorShape* internal_default_instance() {
    return reinterpret_cast<const TensorShape*>(
               &_TensorShape_default_instance_);
  }
  static  int const kIndexInFileMessages =
    5;

  void Swap(TensorShape* other);
  friend void swap(TensorShape& a, TensorShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorShape* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorShape* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorShape& from);
  void MergeFrom(const TensorShape& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // repeated int32 unknown_dims = 3;
  int unknown_dims_size() const;
  void clear_unknown_dims();
  static const int kUnknownDimsFieldNumber = 3;
  ::google::protobuf::int32 unknown_dims(int index) const;
  void set_unknown_dims(int index, ::google::protobuf::int32 value);
  void add_unknown_dims(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      unknown_dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_unknown_dims();

  // optional string name = 5;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool unknown_shape = 4 [default = false];
  bool has_unknown_shape() const;
  void clear_unknown_shape();
  static const int kUnknownShapeFieldNumber = 4;
  bool unknown_shape() const;
  void set_unknown_shape(bool value);

  // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);

  // @@protoc_insertion_point(class_scope:caffe2.TensorShape)
 private:
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_unknown_shape();
  void clear_has_unknown_shape();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > unknown_dims_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool unknown_shape_;
  int data_type_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsTensorShapeImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API TensorShapes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorShapes) */ {
 public:
  TensorShapes();
  virtual ~TensorShapes();

  TensorShapes(const TensorShapes& from);

  inline TensorShapes& operator=(const TensorShapes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorShapes(TensorShapes&& from) noexcept
    : TensorShapes() {
    *this = ::std::move(from);
  }

  inline TensorShapes& operator=(TensorShapes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorShapes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorShapes* internal_default_instance() {
    return reinterpret_cast<const TensorShapes*>(
               &_TensorShapes_default_instance_);
  }
  static  int const kIndexInFileMessages =
    6;

  void Swap(TensorShapes* other);
  friend void swap(TensorShapes& a, TensorShapes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorShapes* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorShapes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorShapes& from);
  void MergeFrom(const TensorShapes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorShapes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.TensorShape shapes = 1;
  int shapes_size() const;
  void clear_shapes();
  static const int kShapesFieldNumber = 1;
  const ::caffe2::TensorShape& shapes(int index) const;
  ::caffe2::TensorShape* mutable_shapes(int index);
  ::caffe2::TensorShape* add_shapes();
  ::google::protobuf::RepeatedPtrField< ::caffe2::TensorShape >*
      mutable_shapes();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::TensorShape >&
      shapes() const;

  // @@protoc_insertion_point(class_scope:caffe2.TensorShapes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::TensorShape > shapes_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsTensorShapesImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API Argument : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(Argument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static  int const kIndexInFileMessages =
    7;

  void Swap(Argument* other);
  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Argument* New() const PROTOBUF_FINAL { return New(NULL); }

  Argument* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float floats = 5;
  int floats_size() const;
  void clear_floats();
  static const int kFloatsFieldNumber = 5;
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::google::protobuf::RepeatedField< float >&
      floats() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_floats();

  // repeated int64 ints = 6;
  int ints_size() const;
  void clear_ints();
  static const int kIntsFieldNumber = 6;
  ::google::protobuf::int64 ints(int index) const;
  void set_ints(int index, ::google::protobuf::int64 value);
  void add_ints(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      ints() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_ints();

  // repeated bytes strings = 7;
  int strings_size() const;
  void clear_strings();
  static const int kStringsFieldNumber = 7;
  const ::std::string& strings(int index) const;
  ::std::string* mutable_strings(int index);
  void set_strings(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_strings(int index, ::std::string&& value);
  #endif
  void set_strings(int index, const char* value);
  void set_strings(int index, const void* value, size_t size);
  ::std::string* add_strings();
  void add_strings(const ::std::string& value);
  #if LANG_CXX11
  void add_strings(::std::string&& value);
  #endif
  void add_strings(const char* value);
  void add_strings(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& strings() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_strings();

  // repeated .caffe2.NetDef nets = 9;
  int nets_size() const;
  void clear_nets();
  static const int kNetsFieldNumber = 9;
  const ::caffe2::NetDef& nets(int index) const;
  ::caffe2::NetDef* mutable_nets(int index);
  ::caffe2::NetDef* add_nets();
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >*
      mutable_nets();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >&
      nets() const;

  // repeated .caffe2.TensorProto tensors = 11;
  int tensors_size() const;
  void clear_tensors();
  static const int kTensorsFieldNumber = 11;
  const ::caffe2::TensorProto& tensors(int index) const;
  ::caffe2::TensorProto* mutable_tensors(int index);
  ::caffe2::TensorProto* add_tensors();
  ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >*
      mutable_tensors();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >&
      tensors() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes s = 4;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 4;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  #if LANG_CXX11
  void set_s(::std::string&& value);
  #endif
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);

  // optional .caffe2.NetDef n = 8;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 8;
  const ::caffe2::NetDef& n() const;
  ::caffe2::NetDef* release_n();
  ::caffe2::NetDef* mutable_n();
  void set_allocated_n(::caffe2::NetDef* n);

  // optional .caffe2.TensorProto t = 10;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 10;
  const ::caffe2::TensorProto& t() const;
  ::caffe2::TensorProto* release_t();
  ::caffe2::TensorProto* mutable_t();
  void set_allocated_t(::caffe2::TensorProto* t);

  // optional int64 i = 3;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 3;
  ::google::protobuf::int64 i() const;
  void set_i(::google::protobuf::int64 value);

  // optional float f = 2;
  bool has_f() const;
  void clear_f();
  static const int kFFieldNumber = 2;
  float f() const;
  void set_f(float value);

  // @@protoc_insertion_point(class_scope:caffe2.Argument)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_f();
  void clear_has_f();
  void set_has_i();
  void clear_has_i();
  void set_has_s();
  void clear_has_s();
  void set_has_t();
  void clear_has_t();
  void set_has_n();
  void clear_has_n();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > floats_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > ints_;
  ::google::protobuf::RepeatedPtrField< ::std::string> strings_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef > nets_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto > tensors_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr s_;
  ::caffe2::NetDef* n_;
  ::caffe2::TensorProto* t_;
  ::google::protobuf::int64 i_;
  float f_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsArgumentImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API DeviceOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.DeviceOption) */ {
 public:
  DeviceOption();
  virtual ~DeviceOption();

  DeviceOption(const DeviceOption& from);

  inline DeviceOption& operator=(const DeviceOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceOption(DeviceOption&& from) noexcept
    : DeviceOption() {
    *this = ::std::move(from);
  }

  inline DeviceOption& operator=(DeviceOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceOption* internal_default_instance() {
    return reinterpret_cast<const DeviceOption*>(
               &_DeviceOption_default_instance_);
  }
  static  int const kIndexInFileMessages =
    8;

  void Swap(DeviceOption* other);
  friend void swap(DeviceOption& a, DeviceOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceOption* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceOption& from);
  void MergeFrom(const DeviceOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string extra_info = 6;
  int extra_info_size() const;
  void clear_extra_info();
  static const int kExtraInfoFieldNumber = 6;
  const ::std::string& extra_info(int index) const;
  ::std::string* mutable_extra_info(int index);
  void set_extra_info(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_extra_info(int index, ::std::string&& value);
  #endif
  void set_extra_info(int index, const char* value);
  void set_extra_info(int index, const char* value, size_t size);
  ::std::string* add_extra_info();
  void add_extra_info(const ::std::string& value);
  #if LANG_CXX11
  void add_extra_info(::std::string&& value);
  #endif
  void add_extra_info(const char* value);
  void add_extra_info(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& extra_info() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_extra_info();

  // optional string node_name = 4;
  bool has_node_name() const;
  void clear_node_name();
  static const int kNodeNameFieldNumber = 4;
  const ::std::string& node_name() const;
  void set_node_name(const ::std::string& value);
  #if LANG_CXX11
  void set_node_name(::std::string&& value);
  #endif
  void set_node_name(const char* value);
  void set_node_name(const char* value, size_t size);
  ::std::string* mutable_node_name();
  ::std::string* release_node_name();
  void set_allocated_node_name(::std::string* node_name);

  // optional int32 device_type = 1 [default = 0];
  bool has_device_type() const;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::google::protobuf::int32 device_type() const;
  void set_device_type(::google::protobuf::int32 value);

  // optional int32 device_id = 2;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 2;
  ::google::protobuf::int32 device_id() const;
  void set_device_id(::google::protobuf::int32 value);

  // optional uint32 random_seed = 3;
  bool has_random_seed() const;
  void clear_random_seed();
  static const int kRandomSeedFieldNumber = 3;
  ::google::protobuf::uint32 random_seed() const;
  void set_random_seed(::google::protobuf::uint32 value);

  // optional int32 numa_node_id = 5;
  bool has_numa_node_id() const;
  void clear_numa_node_id();
  static const int kNumaNodeIdFieldNumber = 5;
  ::google::protobuf::int32 numa_node_id() const;
  void set_numa_node_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe2.DeviceOption)
 private:
  void set_has_device_type();
  void clear_has_device_type();
  void set_has_device_id();
  void clear_has_device_id();
  void set_has_random_seed();
  void clear_has_random_seed();
  void set_has_node_name();
  void clear_has_node_name();
  void set_has_numa_node_id();
  void clear_has_numa_node_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> extra_info_;
  ::google::protobuf::internal::ArenaStringPtr node_name_;
  ::google::protobuf::int32 device_type_;
  ::google::protobuf::int32 device_id_;
  ::google::protobuf::uint32 random_seed_;
  ::google::protobuf::int32 numa_node_id_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsDeviceOptionImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API OperatorDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.OperatorDef) */ {
 public:
  OperatorDef();
  virtual ~OperatorDef();

  OperatorDef(const OperatorDef& from);

  inline OperatorDef& operator=(const OperatorDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperatorDef(OperatorDef&& from) noexcept
    : OperatorDef() {
    *this = ::std::move(from);
  }

  inline OperatorDef& operator=(OperatorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatorDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatorDef* internal_default_instance() {
    return reinterpret_cast<const OperatorDef*>(
               &_OperatorDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    9;

  void Swap(OperatorDef* other);
  friend void swap(OperatorDef& a, OperatorDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperatorDef* New() const PROTOBUF_FINAL { return New(NULL); }

  OperatorDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperatorDef& from);
  void MergeFrom(const OperatorDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperatorDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 1;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  const ::std::string& input(int index) const;
  ::std::string* mutable_input(int index);
  void set_input(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_input(int index, ::std::string&& value);
  #endif
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  ::std::string* add_input();
  void add_input(const ::std::string& value);
  #if LANG_CXX11
  void add_input(::std::string&& value);
  #endif
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // repeated string output = 2;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 2;
  const ::std::string& output(int index) const;
  ::std::string* mutable_output(int index);
  void set_output(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_output(int index, ::std::string&& value);
  #endif
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  ::std::string* add_output();
  void add_output(const ::std::string& value);
  #if LANG_CXX11
  void add_output(::std::string&& value);
  #endif
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& output() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output();

  // repeated .caffe2.Argument arg = 5;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 5;
  const ::caffe2::Argument& arg(int index) const;
  ::caffe2::Argument* mutable_arg(int index);
  ::caffe2::Argument* add_arg();
  ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >&
      arg() const;

  // repeated string control_input = 8;
  int control_input_size() const;
  void clear_control_input();
  static const int kControlInputFieldNumber = 8;
  const ::std::string& control_input(int index) const;
  ::std::string* mutable_control_input(int index);
  void set_control_input(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_control_input(int index, ::std::string&& value);
  #endif
  void set_control_input(int index, const char* value);
  void set_control_input(int index, const char* value, size_t size);
  ::std::string* add_control_input();
  void add_control_input(const ::std::string& value);
  #if LANG_CXX11
  void add_control_input(::std::string&& value);
  #endif
  void add_control_input(const char* value);
  void add_control_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& control_input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_control_input();

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string engine = 7;
  bool has_engine() const;
  void clear_engine();
  static const int kEngineFieldNumber = 7;
  const ::std::string& engine() const;
  void set_engine(const ::std::string& value);
  #if LANG_CXX11
  void set_engine(::std::string&& value);
  #endif
  void set_engine(const char* value);
  void set_engine(const char* value, size_t size);
  ::std::string* mutable_engine();
  ::std::string* release_engine();
  void set_allocated_engine(::std::string* engine);

  // optional string debug_info = 10;
  bool has_debug_info() const;
  void clear_debug_info();
  static const int kDebugInfoFieldNumber = 10;
  const ::std::string& debug_info() const;
  void set_debug_info(const ::std::string& value);
  #if LANG_CXX11
  void set_debug_info(::std::string&& value);
  #endif
  void set_debug_info(const char* value);
  void set_debug_info(const char* value, size_t size);
  ::std::string* mutable_debug_info();
  ::std::string* release_debug_info();
  void set_allocated_debug_info(::std::string* debug_info);

  // optional string domain = 11;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 11;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional .caffe2.DeviceOption device_option = 6;
  bool has_device_option() const;
  void clear_device_option();
  static const int kDeviceOptionFieldNumber = 6;
  const ::caffe2::DeviceOption& device_option() const;
  ::caffe2::DeviceOption* release_device_option();
  ::caffe2::DeviceOption* mutable_device_option();
  void set_allocated_device_option(::caffe2::DeviceOption* device_option);

  // optional int64 op_version = 12;
  bool has_op_version() const;
  void clear_op_version();
  static const int kOpVersionFieldNumber = 12;
  ::google::protobuf::int64 op_version() const;
  void set_op_version(::google::protobuf::int64 value);

  // optional bool is_gradient_op = 9 [default = false];
  bool has_is_gradient_op() const;
  void clear_is_gradient_op();
  static const int kIsGradientOpFieldNumber = 9;
  bool is_gradient_op() const;
  void set_is_gradient_op(bool value);

  // @@protoc_insertion_point(class_scope:caffe2.OperatorDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_device_option();
  void clear_has_device_option();
  void set_has_engine();
  void clear_has_engine();
  void set_has_is_gradient_op();
  void clear_has_is_gradient_op();
  void set_has_debug_info();
  void clear_has_debug_info();
  void set_has_domain();
  void clear_has_domain();
  void set_has_op_version();
  void clear_has_op_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::Argument > arg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> control_input_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr engine_;
  ::google::protobuf::internal::ArenaStringPtr debug_info_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::caffe2::DeviceOption* device_option_;
  ::google::protobuf::int64 op_version_;
  bool is_gradient_op_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsArgumentImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API NetDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.NetDef) */ {
 public:
  NetDef();
  virtual ~NetDef();

  NetDef(const NetDef& from);

  inline NetDef& operator=(const NetDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetDef(NetDef&& from) noexcept
    : NetDef() {
    *this = ::std::move(from);
  }

  inline NetDef& operator=(NetDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetDef* internal_default_instance() {
    return reinterpret_cast<const NetDef*>(
               &_NetDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    10;

  void Swap(NetDef* other);
  friend void swap(NetDef& a, NetDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetDef* New() const PROTOBUF_FINAL { return New(NULL); }

  NetDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetDef& from);
  void MergeFrom(const NetDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.OperatorDef op = 2;
  int op_size() const;
  void clear_op();
  static const int kOpFieldNumber = 2;
  const ::caffe2::OperatorDef& op(int index) const;
  ::caffe2::OperatorDef* mutable_op(int index);
  ::caffe2::OperatorDef* add_op();
  ::google::protobuf::RepeatedPtrField< ::caffe2::OperatorDef >*
      mutable_op();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::OperatorDef >&
      op() const;

  // repeated .caffe2.Argument arg = 6;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 6;
  const ::caffe2::Argument& arg(int index) const;
  ::caffe2::Argument* mutable_arg(int index);
  ::caffe2::Argument* add_arg();
  ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >&
      arg() const;

  // repeated string external_input = 7;
  int external_input_size() const;
  void clear_external_input();
  static const int kExternalInputFieldNumber = 7;
  const ::std::string& external_input(int index) const;
  ::std::string* mutable_external_input(int index);
  void set_external_input(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_external_input(int index, ::std::string&& value);
  #endif
  void set_external_input(int index, const char* value);
  void set_external_input(int index, const char* value, size_t size);
  ::std::string* add_external_input();
  void add_external_input(const ::std::string& value);
  #if LANG_CXX11
  void add_external_input(::std::string&& value);
  #endif
  void add_external_input(const char* value);
  void add_external_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& external_input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_external_input();

  // repeated string external_output = 8;
  int external_output_size() const;
  void clear_external_output();
  static const int kExternalOutputFieldNumber = 8;
  const ::std::string& external_output(int index) const;
  ::std::string* mutable_external_output(int index);
  void set_external_output(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_external_output(int index, ::std::string&& value);
  #endif
  void set_external_output(int index, const char* value);
  void set_external_output(int index, const char* value, size_t size);
  ::std::string* add_external_output();
  void add_external_output(const ::std::string& value);
  #if LANG_CXX11
  void add_external_output(::std::string&& value);
  #endif
  void add_external_output(const char* value);
  void add_external_output(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& external_output() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_external_output();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional .caffe2.DeviceOption device_option = 5;
  bool has_device_option() const;
  void clear_device_option();
  static const int kDeviceOptionFieldNumber = 5;
  const ::caffe2::DeviceOption& device_option() const;
  ::caffe2::DeviceOption* release_device_option();
  ::caffe2::DeviceOption* mutable_device_option();
  void set_allocated_device_option(::caffe2::DeviceOption* device_option);

  // optional int32 num_workers = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_num_workers() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_num_workers();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kNumWorkersFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 num_workers() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_num_workers(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe2.NetDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_num_workers();
  void clear_has_num_workers();
  void set_has_device_option();
  void clear_has_device_option();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::OperatorDef > op_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::Argument > arg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> external_input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> external_output_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::caffe2::DeviceOption* device_option_;
  ::google::protobuf::int32 num_workers_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsArgumentImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API ExecutionStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.ExecutionStep) */ {
 public:
  ExecutionStep();
  virtual ~ExecutionStep();

  ExecutionStep(const ExecutionStep& from);

  inline ExecutionStep& operator=(const ExecutionStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecutionStep(ExecutionStep&& from) noexcept
    : ExecutionStep() {
    *this = ::std::move(from);
  }

  inline ExecutionStep& operator=(ExecutionStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutionStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutionStep* internal_default_instance() {
    return reinterpret_cast<const ExecutionStep*>(
               &_ExecutionStep_default_instance_);
  }
  static  int const kIndexInFileMessages =
    11;

  void Swap(ExecutionStep* other);
  friend void swap(ExecutionStep& a, ExecutionStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecutionStep* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecutionStep* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecutionStep& from);
  void MergeFrom(const ExecutionStep& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecutionStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.ExecutionStep substep = 2;
  int substep_size() const;
  void clear_substep();
  static const int kSubstepFieldNumber = 2;
  const ::caffe2::ExecutionStep& substep(int index) const;
  ::caffe2::ExecutionStep* mutable_substep(int index);
  ::caffe2::ExecutionStep* add_substep();
  ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >*
      mutable_substep();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >&
      substep() const;

  // repeated string network = 3;
  int network_size() const;
  void clear_network();
  static const int kNetworkFieldNumber = 3;
  const ::std::string& network(int index) const;
  ::std::string* mutable_network(int index);
  void set_network(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_network(int index, ::std::string&& value);
  #endif
  void set_network(int index, const char* value);
  void set_network(int index, const char* value, size_t size);
  ::std::string* add_network();
  void add_network(const ::std::string& value);
  #if LANG_CXX11
  void add_network(::std::string&& value);
  #endif
  void add_network(const char* value);
  void add_network(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& network() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_network();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string criteria_network = 5 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_criteria_network() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_criteria_network();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kCriteriaNetworkFieldNumber = 5;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& criteria_network() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_criteria_network(const ::std::string& value);
  #if LANG_CXX11
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_criteria_network(::std::string&& value);
  #endif
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_criteria_network(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_criteria_network(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_criteria_network();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_criteria_network();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_criteria_network(::std::string* criteria_network);

  // optional string report_net = 7;
  bool has_report_net() const;
  void clear_report_net();
  static const int kReportNetFieldNumber = 7;
  const ::std::string& report_net() const;
  void set_report_net(const ::std::string& value);
  #if LANG_CXX11
  void set_report_net(::std::string&& value);
  #endif
  void set_report_net(const char* value);
  void set_report_net(const char* value, size_t size);
  ::std::string* mutable_report_net();
  ::std::string* release_report_net();
  void set_allocated_report_net(::std::string* report_net);

  // optional string should_stop_blob = 9;
  bool has_should_stop_blob() const;
  void clear_should_stop_blob();
  static const int kShouldStopBlobFieldNumber = 9;
  const ::std::string& should_stop_blob() const;
  void set_should_stop_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_should_stop_blob(::std::string&& value);
  #endif
  void set_should_stop_blob(const char* value);
  void set_should_stop_blob(const char* value, size_t size);
  ::std::string* mutable_should_stop_blob();
  ::std::string* release_should_stop_blob();
  void set_allocated_should_stop_blob(::std::string* should_stop_blob);

  // optional int64 num_iter = 4;
  bool has_num_iter() const;
  void clear_num_iter();
  static const int kNumIterFieldNumber = 4;
  ::google::protobuf::int64 num_iter() const;
  void set_num_iter(::google::protobuf::int64 value);

  // optional int32 report_interval = 8;
  bool has_report_interval() const;
  void clear_report_interval();
  static const int kReportIntervalFieldNumber = 8;
  ::google::protobuf::int32 report_interval() const;
  void set_report_interval(::google::protobuf::int32 value);

  // optional bool concurrent_substeps = 6;
  bool has_concurrent_substeps() const;
  void clear_concurrent_substeps();
  static const int kConcurrentSubstepsFieldNumber = 6;
  bool concurrent_substeps() const;
  void set_concurrent_substeps(bool value);

  // optional bool only_once = 10;
  bool has_only_once() const;
  void clear_only_once();
  static const int kOnlyOnceFieldNumber = 10;
  bool only_once() const;
  void set_only_once(bool value);

  // optional bool create_workspace = 12;
  bool has_create_workspace() const;
  void clear_create_workspace();
  static const int kCreateWorkspaceFieldNumber = 12;
  bool create_workspace() const;
  void set_create_workspace(bool value);

  // optional int64 run_every_ms = 11;
  bool has_run_every_ms() const;
  void clear_run_every_ms();
  static const int kRunEveryMsFieldNumber = 11;
  ::google::protobuf::int64 run_every_ms() const;
  void set_run_every_ms(::google::protobuf::int64 value);

  // optional int32 num_concurrent_instances = 13;
  bool has_num_concurrent_instances() const;
  void clear_num_concurrent_instances();
  static const int kNumConcurrentInstancesFieldNumber = 13;
  ::google::protobuf::int32 num_concurrent_instances() const;
  void set_num_concurrent_instances(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe2.ExecutionStep)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_num_iter();
  void clear_has_num_iter();
  void set_has_criteria_network();
  void clear_has_criteria_network();
  void set_has_report_net();
  void clear_has_report_net();
  void set_has_report_interval();
  void clear_has_report_interval();
  void set_has_run_every_ms();
  void clear_has_run_every_ms();
  void set_has_concurrent_substeps();
  void clear_has_concurrent_substeps();
  void set_has_should_stop_blob();
  void clear_has_should_stop_blob();
  void set_has_only_once();
  void clear_has_only_once();
  void set_has_create_workspace();
  void clear_has_create_workspace();
  void set_has_num_concurrent_instances();
  void clear_has_num_concurrent_instances();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep > substep_;
  ::google::protobuf::RepeatedPtrField< ::std::string> network_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr criteria_network_;
  ::google::protobuf::internal::ArenaStringPtr report_net_;
  ::google::protobuf::internal::ArenaStringPtr should_stop_blob_;
  ::google::protobuf::int64 num_iter_;
  ::google::protobuf::int32 report_interval_;
  bool concurrent_substeps_;
  bool only_once_;
  bool create_workspace_;
  ::google::protobuf::int64 run_every_ms_;
  ::google::protobuf::int32 num_concurrent_instances_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsExecutionStepImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API PlanDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.PlanDef) */ {
 public:
  PlanDef();
  virtual ~PlanDef();

  PlanDef(const PlanDef& from);

  inline PlanDef& operator=(const PlanDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanDef(PlanDef&& from) noexcept
    : PlanDef() {
    *this = ::std::move(from);
  }

  inline PlanDef& operator=(PlanDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanDef* internal_default_instance() {
    return reinterpret_cast<const PlanDef*>(
               &_PlanDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    12;

  void Swap(PlanDef* other);
  friend void swap(PlanDef& a, PlanDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanDef* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanDef& from);
  void MergeFrom(const PlanDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.NetDef network = 2;
  int network_size() const;
  void clear_network();
  static const int kNetworkFieldNumber = 2;
  const ::caffe2::NetDef& network(int index) const;
  ::caffe2::NetDef* mutable_network(int index);
  ::caffe2::NetDef* add_network();
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >*
      mutable_network();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >&
      network() const;

  // repeated .caffe2.ExecutionStep execution_step = 3;
  int execution_step_size() const;
  void clear_execution_step();
  static const int kExecutionStepFieldNumber = 3;
  const ::caffe2::ExecutionStep& execution_step(int index) const;
  ::caffe2::ExecutionStep* mutable_execution_step(int index);
  ::caffe2::ExecutionStep* add_execution_step();
  ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >*
      mutable_execution_step();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >&
      execution_step() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:caffe2.PlanDef)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef > network_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep > execution_step_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsPlanDefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API BlobProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.BlobProto) */ {
 public:
  BlobProto();
  virtual ~BlobProto();

  BlobProto(const BlobProto& from);

  inline BlobProto& operator=(const BlobProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlobProto(BlobProto&& from) noexcept
    : BlobProto() {
    *this = ::std::move(from);
  }

  inline BlobProto& operator=(BlobProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobProto* internal_default_instance() {
    return reinterpret_cast<const BlobProto*>(
               &_BlobProto_default_instance_);
  }
  static  int const kIndexInFileMessages =
    13;

  void Swap(BlobProto* other);
  friend void swap(BlobProto& a, BlobProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlobProto* New() const PROTOBUF_FINAL { return New(NULL); }

  BlobProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlobProto& from);
  void MergeFrom(const BlobProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlobProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional bytes content = 4;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 4;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional .caffe2.TensorProto tensor = 3;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 3;
  const ::caffe2::TensorProto& tensor() const;
  ::caffe2::TensorProto* release_tensor();
  ::caffe2::TensorProto* mutable_tensor();
  void set_allocated_tensor(::caffe2::TensorProto* tensor);

  // optional .caffe2.QTensorProto qtensor = 5;
  bool has_qtensor() const;
  void clear_qtensor();
  static const int kQtensorFieldNumber = 5;
  const ::caffe2::QTensorProto& qtensor() const;
  ::caffe2::QTensorProto* release_qtensor();
  ::caffe2::QTensorProto* mutable_qtensor();
  void set_allocated_qtensor(::caffe2::QTensorProto* qtensor);

  // optional int32 content_num_chunks = 6;
  bool has_content_num_chunks() const;
  void clear_content_num_chunks();
  static const int kContentNumChunksFieldNumber = 6;
  ::google::protobuf::int32 content_num_chunks() const;
  void set_content_num_chunks(::google::protobuf::int32 value);

  // optional int32 content_chunk_id = 7;
  bool has_content_chunk_id() const;
  void clear_content_chunk_id();
  static const int kContentChunkIdFieldNumber = 7;
  ::google::protobuf::int32 content_chunk_id() const;
  void set_content_chunk_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe2.BlobProto)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_tensor();
  void clear_has_tensor();
  void set_has_content();
  void clear_has_content();
  void set_has_qtensor();
  void clear_has_qtensor();
  void set_has_content_num_chunks();
  void clear_has_content_num_chunks();
  void set_has_content_chunk_id();
  void clear_has_content_chunk_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::caffe2::TensorProto* tensor_;
  ::caffe2::QTensorProto* qtensor_;
  ::google::protobuf::int32 content_num_chunks_;
  ::google::protobuf::int32 content_chunk_id_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsBlobProtoImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API DBReaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.DBReaderProto) */ {
 public:
  DBReaderProto();
  virtual ~DBReaderProto();

  DBReaderProto(const DBReaderProto& from);

  inline DBReaderProto& operator=(const DBReaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DBReaderProto(DBReaderProto&& from) noexcept
    : DBReaderProto() {
    *this = ::std::move(from);
  }

  inline DBReaderProto& operator=(DBReaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBReaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBReaderProto* internal_default_instance() {
    return reinterpret_cast<const DBReaderProto*>(
               &_DBReaderProto_default_instance_);
  }
  static  int const kIndexInFileMessages =
    14;

  void Swap(DBReaderProto* other);
  friend void swap(DBReaderProto& a, DBReaderProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DBReaderProto* New() const PROTOBUF_FINAL { return New(NULL); }

  DBReaderProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DBReaderProto& from);
  void MergeFrom(const DBReaderProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DBReaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // optional string db_type = 3;
  bool has_db_type() const;
  void clear_db_type();
  static const int kDbTypeFieldNumber = 3;
  const ::std::string& db_type() const;
  void set_db_type(const ::std::string& value);
  #if LANG_CXX11
  void set_db_type(::std::string&& value);
  #endif
  void set_db_type(const char* value);
  void set_db_type(const char* value, size_t size);
  ::std::string* mutable_db_type();
  ::std::string* release_db_type();
  void set_allocated_db_type(::std::string* db_type);

  // optional string key = 4;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:caffe2.DBReaderProto)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_source();
  void clear_has_source();
  void set_has_db_type();
  void clear_has_db_type();
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr db_type_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2fcaffe2_2eproto::InitDefaultsDBReaderProtoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExternalDataProto

// optional .caffe2.ExternalDataProto.SourceType source_type = 1 [default = INLINE_CONTAINER];
inline bool ExternalDataProto::has_source_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExternalDataProto::set_has_source_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExternalDataProto::clear_has_source_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExternalDataProto::clear_source_type() {
  source_type_ = 0;
  clear_has_source_type();
}
inline ::caffe2::ExternalDataProto_SourceType ExternalDataProto::source_type() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.source_type)
  return static_cast< ::caffe2::ExternalDataProto_SourceType >(source_type_);
}
inline void ExternalDataProto::set_source_type(::caffe2::ExternalDataProto_SourceType value) {
  assert(::caffe2::ExternalDataProto_SourceType_IsValid(value));
  set_has_source_type();
  source_type_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.source_type)
}

// optional string record_id = 2;
inline bool ExternalDataProto::has_record_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalDataProto::set_has_record_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalDataProto::clear_has_record_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalDataProto::clear_record_id() {
  record_id_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_record_id();
}
inline const ::std::string& ExternalDataProto::record_id() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.record_id)
  return record_id_.GetNoArena();
}
inline void ExternalDataProto::set_record_id(const ::std::string& value) {
  set_has_record_id();
  record_id_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.record_id)
}
#if LANG_CXX11
inline void ExternalDataProto::set_record_id(::std::string&& value) {
  set_has_record_id();
  record_id_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExternalDataProto.record_id)
}
#endif
inline void ExternalDataProto::set_record_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_record_id();
  record_id_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExternalDataProto.record_id)
}
inline void ExternalDataProto::set_record_id(const char* value, size_t size) {
  set_has_record_id();
  record_id_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExternalDataProto.record_id)
}
inline ::std::string* ExternalDataProto::mutable_record_id() {
  set_has_record_id();
  // @@protoc_insertion_point(field_mutable:caffe2.ExternalDataProto.record_id)
  return record_id_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalDataProto::release_record_id() {
  // @@protoc_insertion_point(field_release:caffe2.ExternalDataProto.record_id)
  clear_has_record_id();
  return record_id_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExternalDataProto::set_allocated_record_id(::std::string* record_id) {
  if (record_id != NULL) {
    set_has_record_id();
  } else {
    clear_has_record_id();
  }
  record_id_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), record_id);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExternalDataProto.record_id)
}

// optional uint64 record_size = 5;
inline bool ExternalDataProto::has_record_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalDataProto::set_has_record_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalDataProto::clear_has_record_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalDataProto::clear_record_size() {
  record_size_ = GOOGLE_ULONGLONG(0);
  clear_has_record_size();
}
inline ::google::protobuf::uint64 ExternalDataProto::record_size() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.record_size)
  return record_size_;
}
inline void ExternalDataProto::set_record_size(::google::protobuf::uint64 value) {
  set_has_record_size();
  record_size_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.record_size)
}

// optional int64 offset = 3 [default = 0];
inline bool ExternalDataProto::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalDataProto::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalDataProto::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalDataProto::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 ExternalDataProto::offset() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.offset)
  return offset_;
}
inline void ExternalDataProto::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.offset)
}

// repeated int64 strides = 4;
inline int ExternalDataProto::strides_size() const {
  return strides_.size();
}
inline void ExternalDataProto::clear_strides() {
  strides_.Clear();
}
inline ::google::protobuf::int64 ExternalDataProto::strides(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.strides)
  return strides_.Get(index);
}
inline void ExternalDataProto::set_strides(int index, ::google::protobuf::int64 value) {
  strides_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.strides)
}
inline void ExternalDataProto::add_strides(::google::protobuf::int64 value) {
  strides_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.ExternalDataProto.strides)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ExternalDataProto::strides() const {
  // @@protoc_insertion_point(field_list:caffe2.ExternalDataProto.strides)
  return strides_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ExternalDataProto::mutable_strides() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.ExternalDataProto.strides)
  return &strides_;
}

// -------------------------------------------------------------------

// TensorProto_Segment

// required int64 begin = 1;
inline bool TensorProto_Segment::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TensorProto_Segment::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TensorProto_Segment::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TensorProto_Segment::clear_begin() {
  begin_ = GOOGLE_LONGLONG(0);
  clear_has_begin();
}
inline ::google::protobuf::int64 TensorProto_Segment::begin() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.Segment.begin)
  return begin_;
}
inline void TensorProto_Segment::set_begin(::google::protobuf::int64 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.Segment.begin)
}

// required int64 end = 2;
inline bool TensorProto_Segment::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TensorProto_Segment::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TensorProto_Segment::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TensorProto_Segment::clear_end() {
  end_ = GOOGLE_LONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::int64 TensorProto_Segment::end() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.Segment.end)
  return end_;
}
inline void TensorProto_Segment::set_end(::google::protobuf::int64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.Segment.end)
}

// -------------------------------------------------------------------

// TensorProto

// repeated int64 dims = 1;
inline int TensorProto::dims_size() const {
  return dims_.size();
}
inline void TensorProto::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 TensorProto::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.dims)
  return dims_.Get(index);
}
inline void TensorProto::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.dims)
}
inline void TensorProto::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TensorProto::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TensorProto::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.dims)
  return &dims_;
}

// optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
inline bool TensorProto::has_data_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TensorProto::set_has_data_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TensorProto::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TensorProto::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::caffe2::TensorProto_DataType TensorProto::data_type() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.data_type)
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline void TensorProto::set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.data_type)
}

// optional .caffe2.TensorProto.StorageType storage_type = 12 [default = TYPED];
inline bool TensorProto::has_storage_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TensorProto::set_has_storage_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TensorProto::clear_has_storage_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TensorProto::clear_storage_type() {
  storage_type_ = 1;
  clear_has_storage_type();
}
inline ::caffe2::TensorProto_StorageType TensorProto::storage_type() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.storage_type)
  return static_cast< ::caffe2::TensorProto_StorageType >(storage_type_);
}
inline void TensorProto::set_storage_type(::caffe2::TensorProto_StorageType value) {
  assert(::caffe2::TensorProto_StorageType_IsValid(value));
  set_has_storage_type();
  storage_type_ = value;
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.storage_type)
}

// repeated float float_data = 3 [packed = true];
inline int TensorProto::float_data_size() const {
  return float_data_.size();
}
inline void TensorProto::clear_float_data() {
  float_data_.Clear();
}
inline float TensorProto::float_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.float_data)
  return float_data_.Get(index);
}
inline void TensorProto::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.float_data)
}
inline void TensorProto::add_float_data(float value) {
  float_data_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.float_data)
}
inline const ::google::protobuf::RepeatedField< float >&
TensorProto::float_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.float_data)
  return float_data_;
}
inline ::google::protobuf::RepeatedField< float >*
TensorProto::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.float_data)
  return &float_data_;
}

// repeated int32 int32_data = 4 [packed = true];
inline int TensorProto::int32_data_size() const {
  return int32_data_.size();
}
inline void TensorProto::clear_int32_data() {
  int32_data_.Clear();
}
inline ::google::protobuf::int32 TensorProto::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.int32_data)
  return int32_data_.Get(index);
}
inline void TensorProto::set_int32_data(int index, ::google::protobuf::int32 value) {
  int32_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.int32_data)
}
inline void TensorProto::add_int32_data(::google::protobuf::int32 value) {
  int32_data_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.int32_data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorProto::int32_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.int32_data)
  return int32_data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorProto::mutable_int32_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.int32_data)
  return &int32_data_;
}

// optional bytes byte_data = 5;
inline bool TensorProto::has_byte_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TensorProto::set_has_byte_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TensorProto::clear_has_byte_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TensorProto::clear_byte_data() {
  byte_data_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_byte_data();
}
inline const ::std::string& TensorProto::byte_data() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.byte_data)
  return byte_data_.GetNoArena();
}
inline void TensorProto::set_byte_data(const ::std::string& value) {
  set_has_byte_data();
  byte_data_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.byte_data)
}
#if LANG_CXX11
inline void TensorProto::set_byte_data(::std::string&& value) {
  set_has_byte_data();
  byte_data_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorProto.byte_data)
}
#endif
inline void TensorProto::set_byte_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_byte_data();
  byte_data_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(const void* value, size_t size) {
  set_has_byte_data();
  byte_data_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.byte_data)
}
inline ::std::string* TensorProto::mutable_byte_data() {
  set_has_byte_data();
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.byte_data)
  return byte_data_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorProto::release_byte_data() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.byte_data)
  clear_has_byte_data();
  return byte_data_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_byte_data(::std::string* byte_data) {
  if (byte_data != NULL) {
    set_has_byte_data();
  } else {
    clear_has_byte_data();
  }
  byte_data_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), byte_data);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.byte_data)
}

// repeated bytes string_data = 6;
inline int TensorProto::string_data_size() const {
  return string_data_.size();
}
inline void TensorProto::clear_string_data() {
  string_data_.Clear();
}
inline const ::std::string& TensorProto::string_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.string_data)
  return string_data_.Get(index);
}
inline ::std::string* TensorProto::mutable_string_data(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.string_data)
  return string_data_.Mutable(index);
}
inline void TensorProto::set_string_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.string_data)
  string_data_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TensorProto::set_string_data(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.string_data)
  string_data_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TensorProto::set_string_data(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  string_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, const void* value, size_t size) {
  string_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.string_data)
}
inline ::std::string* TensorProto::add_string_data() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.TensorProto.string_data)
  return string_data_.Add();
}
inline void TensorProto::add_string_data(const ::std::string& value) {
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.string_data)
}
#if LANG_CXX11
inline void TensorProto::add_string_data(::std::string&& value) {
  string_data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.string_data)
}
#endif
inline void TensorProto::add_string_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const void* value, size_t size) {
  string_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.TensorProto.string_data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TensorProto::string_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.string_data)
  return string_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TensorProto::mutable_string_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.string_data)
  return &string_data_;
}

// repeated double double_data = 9 [packed = true];
inline int TensorProto::double_data_size() const {
  return double_data_.size();
}
inline void TensorProto::clear_double_data() {
  double_data_.Clear();
}
inline double TensorProto::double_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.double_data)
  return double_data_.Get(index);
}
inline void TensorProto::set_double_data(int index, double value) {
  double_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.double_data)
}
inline void TensorProto::add_double_data(double value) {
  double_data_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.double_data)
}
inline const ::google::protobuf::RepeatedField< double >&
TensorProto::double_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.double_data)
  return double_data_;
}
inline ::google::protobuf::RepeatedField< double >*
TensorProto::mutable_double_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.double_data)
  return &double_data_;
}

// repeated int64 int64_data = 10 [packed = true];
inline int TensorProto::int64_data_size() const {
  return int64_data_.size();
}
inline void TensorProto::clear_int64_data() {
  int64_data_.Clear();
}
inline ::google::protobuf::int64 TensorProto::int64_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.int64_data)
  return int64_data_.Get(index);
}
inline void TensorProto::set_int64_data(int index, ::google::protobuf::int64 value) {
  int64_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.int64_data)
}
inline void TensorProto::add_int64_data(::google::protobuf::int64 value) {
  int64_data_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.int64_data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TensorProto::int64_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.int64_data)
  return int64_data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TensorProto::mutable_int64_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.int64_data)
  return &int64_data_;
}

// optional bytes raw_data = 13;
inline bool TensorProto::has_raw_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TensorProto::set_has_raw_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TensorProto::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TensorProto::clear_raw_data() {
  raw_data_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_raw_data();
}
inline const ::std::string& TensorProto::raw_data() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.raw_data)
  return raw_data_.GetNoArena();
}
inline void TensorProto::set_raw_data(const ::std::string& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.raw_data)
}
#if LANG_CXX11
inline void TensorProto::set_raw_data(::std::string&& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorProto.raw_data)
}
#endif
inline void TensorProto::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_raw_data();
  raw_data_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.raw_data)
}
inline void TensorProto::set_raw_data(const void* value, size_t size) {
  set_has_raw_data();
  raw_data_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.raw_data)
}
inline ::std::string* TensorProto::mutable_raw_data() {
  set_has_raw_data();
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.raw_data)
  return raw_data_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorProto::release_raw_data() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.raw_data)
  clear_has_raw_data();
  return raw_data_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_raw_data(::std::string* raw_data) {
  if (raw_data != NULL) {
    set_has_raw_data();
  } else {
    clear_has_raw_data();
  }
  raw_data_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), raw_data);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.raw_data)
}

// optional .caffe2.ExternalDataProto external_data = 14;
inline bool TensorProto::has_external_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TensorProto::set_has_external_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TensorProto::clear_has_external_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TensorProto::clear_external_data() {
  if (external_data_ != NULL) external_data_->Clear();
  clear_has_external_data();
}
inline const ::caffe2::ExternalDataProto& TensorProto::external_data() const {
  const ::caffe2::ExternalDataProto* p = external_data_;
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.external_data)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::ExternalDataProto*>(
      &::caffe2::_ExternalDataProto_default_instance_);
}
inline ::caffe2::ExternalDataProto* TensorProto::release_external_data() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.external_data)
  clear_has_external_data();
  ::caffe2::ExternalDataProto* temp = external_data_;
  external_data_ = NULL;
  return temp;
}
inline ::caffe2::ExternalDataProto* TensorProto::mutable_external_data() {
  set_has_external_data();
  if (external_data_ == NULL) {
    external_data_ = new ::caffe2::ExternalDataProto;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.external_data)
  return external_data_;
}
inline void TensorProto::set_allocated_external_data(::caffe2::ExternalDataProto* external_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete external_data_;
  }
  if (external_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      external_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, external_data, submessage_arena);
    }
    set_has_external_data();
  } else {
    clear_has_external_data();
  }
  external_data_ = external_data;
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.external_data)
}

// optional string name = 7;
inline bool TensorProto::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TensorProto::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TensorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TensorProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TensorProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.name)
  return name_.GetNoArena();
}
inline void TensorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.name)
}
#if LANG_CXX11
inline void TensorProto::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorProto.name)
}
#endif
inline void TensorProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.name)
}
inline void TensorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.name)
}
inline ::std::string* TensorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.name)
}

// optional .caffe2.DeviceOption device_detail = 8;
inline bool TensorProto::has_device_detail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TensorProto::set_has_device_detail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TensorProto::clear_has_device_detail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TensorProto::clear_device_detail() {
  if (device_detail_ != NULL) device_detail_->Clear();
  clear_has_device_detail();
}
inline const ::caffe2::DeviceOption& TensorProto::device_detail() const {
  const ::caffe2::DeviceOption* p = device_detail_;
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.device_detail)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::DeviceOption*>(
      &::caffe2::_DeviceOption_default_instance_);
}
inline ::caffe2::DeviceOption* TensorProto::release_device_detail() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.device_detail)
  clear_has_device_detail();
  ::caffe2::DeviceOption* temp = device_detail_;
  device_detail_ = NULL;
  return temp;
}
inline ::caffe2::DeviceOption* TensorProto::mutable_device_detail() {
  set_has_device_detail();
  if (device_detail_ == NULL) {
    device_detail_ = new ::caffe2::DeviceOption;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.device_detail)
  return device_detail_;
}
inline void TensorProto::set_allocated_device_detail(::caffe2::DeviceOption* device_detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_detail_;
  }
  if (device_detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_detail, submessage_arena);
    }
    set_has_device_detail();
  } else {
    clear_has_device_detail();
  }
  device_detail_ = device_detail;
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.device_detail)
}

// optional .caffe2.TensorProto.Segment segment = 11;
inline bool TensorProto::has_segment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TensorProto::set_has_segment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TensorProto::clear_has_segment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TensorProto::clear_segment() {
  if (segment_ != NULL) segment_->Clear();
  clear_has_segment();
}
inline const ::caffe2::TensorProto_Segment& TensorProto::segment() const {
  const ::caffe2::TensorProto_Segment* p = segment_;
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.segment)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::TensorProto_Segment*>(
      &::caffe2::_TensorProto_Segment_default_instance_);
}
inline ::caffe2::TensorProto_Segment* TensorProto::release_segment() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.segment)
  clear_has_segment();
  ::caffe2::TensorProto_Segment* temp = segment_;
  segment_ = NULL;
  return temp;
}
inline ::caffe2::TensorProto_Segment* TensorProto::mutable_segment() {
  set_has_segment();
  if (segment_ == NULL) {
    segment_ = new ::caffe2::TensorProto_Segment;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.segment)
  return segment_;
}
inline void TensorProto::set_allocated_segment(::caffe2::TensorProto_Segment* segment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete segment_;
  }
  if (segment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      segment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, segment, submessage_arena);
    }
    set_has_segment();
  } else {
    clear_has_segment();
  }
  segment_ = segment;
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.segment)
}

// -------------------------------------------------------------------

// QTensorProto

// repeated int64 dims = 1;
inline int QTensorProto::dims_size() const {
  return dims_.size();
}
inline void QTensorProto::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 QTensorProto::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.dims)
  return dims_.Get(index);
}
inline void QTensorProto::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.dims)
}
inline void QTensorProto::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.QTensorProto.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
QTensorProto::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.QTensorProto.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
QTensorProto::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.QTensorProto.dims)
  return &dims_;
}

// required int32 precision = 2;
inline bool QTensorProto::has_precision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QTensorProto::set_has_precision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QTensorProto::clear_has_precision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QTensorProto::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::google::protobuf::int32 QTensorProto::precision() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.precision)
  return precision_;
}
inline void QTensorProto::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.precision)
}

// required double scale = 3;
inline bool QTensorProto::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QTensorProto::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QTensorProto::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QTensorProto::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double QTensorProto::scale() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.scale)
  return scale_;
}
inline void QTensorProto::set_scale(double value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.scale)
}

// required double bias = 4;
inline bool QTensorProto::has_bias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QTensorProto::set_has_bias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QTensorProto::clear_has_bias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QTensorProto::clear_bias() {
  bias_ = 0;
  clear_has_bias();
}
inline double QTensorProto::bias() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.bias)
  return bias_;
}
inline void QTensorProto::set_bias(double value) {
  set_has_bias();
  bias_ = value;
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.bias)
}

// required bool is_signed = 5;
inline bool QTensorProto::has_is_signed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QTensorProto::set_has_is_signed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QTensorProto::clear_has_is_signed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QTensorProto::clear_is_signed() {
  is_signed_ = false;
  clear_has_is_signed();
}
inline bool QTensorProto::is_signed() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.is_signed)
  return is_signed_;
}
inline void QTensorProto::set_is_signed(bool value) {
  set_has_is_signed();
  is_signed_ = value;
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.is_signed)
}

// repeated int32 data = 6 [packed = true];
inline int QTensorProto::data_size() const {
  return data_.size();
}
inline void QTensorProto::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 QTensorProto::data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.data)
  return data_.Get(index);
}
inline void QTensorProto::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.data)
}
inline void QTensorProto::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.QTensorProto.data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
QTensorProto::data() const {
  // @@protoc_insertion_point(field_list:caffe2.QTensorProto.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
QTensorProto::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.QTensorProto.data)
  return &data_;
}

// optional string name = 7;
inline bool QTensorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QTensorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QTensorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QTensorProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& QTensorProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.name)
  return name_.GetNoArena();
}
inline void QTensorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.name)
}
#if LANG_CXX11
inline void QTensorProto::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.QTensorProto.name)
}
#endif
inline void QTensorProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.QTensorProto.name)
}
inline void QTensorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.QTensorProto.name)
}
inline ::std::string* QTensorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.QTensorProto.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* QTensorProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.QTensorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void QTensorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.QTensorProto.name)
}

// optional .caffe2.TensorProto.DataType data_type = 8 [default = INT32];
inline bool QTensorProto::has_data_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QTensorProto::set_has_data_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QTensorProto::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QTensorProto::clear_data_type() {
  data_type_ = 2;
  clear_has_data_type();
}
inline ::caffe2::TensorProto_DataType QTensorProto::data_type() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.data_type)
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline void QTensorProto::set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.data_type)
}

// -------------------------------------------------------------------

// TensorProtos

// repeated .caffe2.TensorProto protos = 1;
inline int TensorProtos::protos_size() const {
  return protos_.size();
}
inline void TensorProtos::clear_protos() {
  protos_.Clear();
}
inline const ::caffe2::TensorProto& TensorProtos::protos(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProtos.protos)
  return protos_.Get(index);
}
inline ::caffe2::TensorProto* TensorProtos::mutable_protos(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProtos.protos)
  return protos_.Mutable(index);
}
inline ::caffe2::TensorProto* TensorProtos::add_protos() {
  // @@protoc_insertion_point(field_add:caffe2.TensorProtos.protos)
  return protos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >*
TensorProtos::mutable_protos() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProtos.protos)
  return &protos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >&
TensorProtos::protos() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProtos.protos)
  return protos_;
}

// -------------------------------------------------------------------

// TensorShape

// repeated int64 dims = 1;
inline int TensorShape::dims_size() const {
  return dims_.size();
}
inline void TensorShape::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 TensorShape::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.dims)
  return dims_.Get(index);
}
inline void TensorShape::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.dims)
}
inline void TensorShape::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorShape.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TensorShape::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorShape.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TensorShape::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorShape.dims)
  return &dims_;
}

// optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
inline bool TensorShape::has_data_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TensorShape::set_has_data_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TensorShape::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TensorShape::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::caffe2::TensorProto_DataType TensorShape::data_type() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.data_type)
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline void TensorShape::set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.data_type)
}

// repeated int32 unknown_dims = 3;
inline int TensorShape::unknown_dims_size() const {
  return unknown_dims_.size();
}
inline void TensorShape::clear_unknown_dims() {
  unknown_dims_.Clear();
}
inline ::google::protobuf::int32 TensorShape::unknown_dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.unknown_dims)
  return unknown_dims_.Get(index);
}
inline void TensorShape::set_unknown_dims(int index, ::google::protobuf::int32 value) {
  unknown_dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.unknown_dims)
}
inline void TensorShape::add_unknown_dims(::google::protobuf::int32 value) {
  unknown_dims_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorShape.unknown_dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorShape::unknown_dims() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorShape.unknown_dims)
  return unknown_dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorShape::mutable_unknown_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorShape.unknown_dims)
  return &unknown_dims_;
}

// optional bool unknown_shape = 4 [default = false];
inline bool TensorShape::has_unknown_shape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TensorShape::set_has_unknown_shape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TensorShape::clear_has_unknown_shape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TensorShape::clear_unknown_shape() {
  unknown_shape_ = false;
  clear_has_unknown_shape();
}
inline bool TensorShape::unknown_shape() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.unknown_shape)
  return unknown_shape_;
}
inline void TensorShape::set_unknown_shape(bool value) {
  set_has_unknown_shape();
  unknown_shape_ = value;
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.unknown_shape)
}

// optional string name = 5;
inline bool TensorShape::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TensorShape::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TensorShape::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TensorShape::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TensorShape::name() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.name)
  return name_.GetNoArena();
}
inline void TensorShape::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.name)
}
#if LANG_CXX11
inline void TensorShape::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorShape.name)
}
#endif
inline void TensorShape::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorShape.name)
}
inline void TensorShape::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorShape.name)
}
inline ::std::string* TensorShape::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.TensorShape.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorShape::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.TensorShape.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorShape::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorShape.name)
}

// -------------------------------------------------------------------

// TensorShapes

// repeated .caffe2.TensorShape shapes = 1;
inline int TensorShapes::shapes_size() const {
  return shapes_.size();
}
inline void TensorShapes::clear_shapes() {
  shapes_.Clear();
}
inline const ::caffe2::TensorShape& TensorShapes::shapes(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShapes.shapes)
  return shapes_.Get(index);
}
inline ::caffe2::TensorShape* TensorShapes::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorShapes.shapes)
  return shapes_.Mutable(index);
}
inline ::caffe2::TensorShape* TensorShapes::add_shapes() {
  // @@protoc_insertion_point(field_add:caffe2.TensorShapes.shapes)
  return shapes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::TensorShape >*
TensorShapes::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorShapes.shapes)
  return &shapes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::TensorShape >&
TensorShapes::shapes() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorShapes.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// Argument

// optional string name = 1;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.name)
  return name_.GetNoArena();
}
inline void Argument::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.name)
}
#if LANG_CXX11
inline void Argument::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.Argument.name)
}
#endif
inline void Argument::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.Argument.name)
}
inline ::std::string* Argument::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.name)
}

// optional float f = 2;
inline bool Argument::has_f() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Argument::set_has_f() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Argument::clear_has_f() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Argument::clear_f() {
  f_ = 0;
  clear_has_f();
}
inline float Argument::f() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.f)
  return f_;
}
inline void Argument::set_f(float value) {
  set_has_f();
  f_ = value;
  // @@protoc_insertion_point(field_set:caffe2.Argument.f)
}

// optional int64 i = 3;
inline bool Argument::has_i() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Argument::set_has_i() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Argument::clear_has_i() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Argument::clear_i() {
  i_ = GOOGLE_LONGLONG(0);
  clear_has_i();
}
inline ::google::protobuf::int64 Argument::i() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.i)
  return i_;
}
inline void Argument::set_i(::google::protobuf::int64 value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:caffe2.Argument.i)
}

// optional bytes s = 4;
inline bool Argument::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_s() {
  s_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_s();
}
inline const ::std::string& Argument::s() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.s)
  return s_.GetNoArena();
}
inline void Argument::set_s(const ::std::string& value) {
  set_has_s();
  s_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.s)
}
#if LANG_CXX11
inline void Argument::set_s(::std::string&& value) {
  set_has_s();
  s_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.Argument.s)
}
#endif
inline void Argument::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s();
  s_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.Argument.s)
}
inline void Argument::set_s(const void* value, size_t size) {
  set_has_s();
  s_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.Argument.s)
}
inline ::std::string* Argument::mutable_s() {
  set_has_s();
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.s)
  return s_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_s() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.s)
  clear_has_s();
  return s_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    set_has_s();
  } else {
    clear_has_s();
  }
  s_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.s)
}

// optional .caffe2.TensorProto t = 10;
inline bool Argument::has_t() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::set_has_t() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Argument::clear_has_t() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Argument::clear_t() {
  if (t_ != NULL) t_->Clear();
  clear_has_t();
}
inline const ::caffe2::TensorProto& Argument::t() const {
  const ::caffe2::TensorProto* p = t_;
  // @@protoc_insertion_point(field_get:caffe2.Argument.t)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::TensorProto*>(
      &::caffe2::_TensorProto_default_instance_);
}
inline ::caffe2::TensorProto* Argument::release_t() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.t)
  clear_has_t();
  ::caffe2::TensorProto* temp = t_;
  t_ = NULL;
  return temp;
}
inline ::caffe2::TensorProto* Argument::mutable_t() {
  set_has_t();
  if (t_ == NULL) {
    t_ = new ::caffe2::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.t)
  return t_;
}
inline void Argument::set_allocated_t(::caffe2::TensorProto* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    set_has_t();
  } else {
    clear_has_t();
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.t)
}

// optional .caffe2.NetDef n = 8;
inline bool Argument::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Argument::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Argument::clear_n() {
  if (n_ != NULL) n_->Clear();
  clear_has_n();
}
inline const ::caffe2::NetDef& Argument::n() const {
  const ::caffe2::NetDef* p = n_;
  // @@protoc_insertion_point(field_get:caffe2.Argument.n)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline ::caffe2::NetDef* Argument::release_n() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.n)
  clear_has_n();
  ::caffe2::NetDef* temp = n_;
  n_ = NULL;
  return temp;
}
inline ::caffe2::NetDef* Argument::mutable_n() {
  set_has_n();
  if (n_ == NULL) {
    n_ = new ::caffe2::NetDef;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.n)
  return n_;
}
inline void Argument::set_allocated_n(::caffe2::NetDef* n) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete n_;
  }
  if (n) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      n = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, n, submessage_arena);
    }
    set_has_n();
  } else {
    clear_has_n();
  }
  n_ = n;
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.n)
}

// repeated float floats = 5;
inline int Argument::floats_size() const {
  return floats_.size();
}
inline void Argument::clear_floats() {
  floats_.Clear();
}
inline float Argument::floats(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.floats)
  return floats_.Get(index);
}
inline void Argument::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.floats)
}
inline void Argument::add_floats(float value) {
  floats_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.Argument.floats)
}
inline const ::google::protobuf::RepeatedField< float >&
Argument::floats() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.floats)
  return floats_;
}
inline ::google::protobuf::RepeatedField< float >*
Argument::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.floats)
  return &floats_;
}

// repeated int64 ints = 6;
inline int Argument::ints_size() const {
  return ints_.size();
}
inline void Argument::clear_ints() {
  ints_.Clear();
}
inline ::google::protobuf::int64 Argument::ints(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.ints)
  return ints_.Get(index);
}
inline void Argument::set_ints(int index, ::google::protobuf::int64 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.ints)
}
inline void Argument::add_ints(::google::protobuf::int64 value) {
  ints_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.Argument.ints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Argument::ints() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.ints)
  return ints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Argument::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.ints)
  return &ints_;
}

// repeated bytes strings = 7;
inline int Argument::strings_size() const {
  return strings_.size();
}
inline void Argument::clear_strings() {
  strings_.Clear();
}
inline const ::std::string& Argument::strings(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.strings)
  return strings_.Get(index);
}
inline ::std::string* Argument::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.strings)
  return strings_.Mutable(index);
}
inline void Argument::set_strings(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.Argument.strings)
  strings_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Argument::set_strings(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.Argument.strings)
  strings_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Argument::set_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.Argument.strings)
}
inline void Argument::set_strings(int index, const void* value, size_t size) {
  strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.Argument.strings)
}
inline ::std::string* Argument::add_strings() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.Argument.strings)
  return strings_.Add();
}
inline void Argument::add_strings(const ::std::string& value) {
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.Argument.strings)
}
#if LANG_CXX11
inline void Argument::add_strings(::std::string&& value) {
  strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.Argument.strings)
}
#endif
inline void Argument::add_strings(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.Argument.strings)
}
inline void Argument::add_strings(const void* value, size_t size) {
  strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.Argument.strings)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Argument::strings() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.strings)
  return strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Argument::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.strings)
  return &strings_;
}

// repeated .caffe2.TensorProto tensors = 11;
inline int Argument::tensors_size() const {
  return tensors_.size();
}
inline void Argument::clear_tensors() {
  tensors_.Clear();
}
inline const ::caffe2::TensorProto& Argument::tensors(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.tensors)
  return tensors_.Get(index);
}
inline ::caffe2::TensorProto* Argument::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.tensors)
  return tensors_.Mutable(index);
}
inline ::caffe2::TensorProto* Argument::add_tensors() {
  // @@protoc_insertion_point(field_add:caffe2.Argument.tensors)
  return tensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >*
Argument::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.tensors)
  return &tensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::TensorProto >&
Argument::tensors() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.tensors)
  return tensors_;
}

// repeated .caffe2.NetDef nets = 9;
inline int Argument::nets_size() const {
  return nets_.size();
}
inline void Argument::clear_nets() {
  nets_.Clear();
}
inline const ::caffe2::NetDef& Argument::nets(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.nets)
  return nets_.Get(index);
}
inline ::caffe2::NetDef* Argument::mutable_nets(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.nets)
  return nets_.Mutable(index);
}
inline ::caffe2::NetDef* Argument::add_nets() {
  // @@protoc_insertion_point(field_add:caffe2.Argument.nets)
  return nets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >*
Argument::mutable_nets() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.nets)
  return &nets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >&
Argument::nets() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.nets)
  return nets_;
}

// -------------------------------------------------------------------

// DeviceOption

// optional int32 device_type = 1 [default = 0];
inline bool DeviceOption::has_device_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceOption::set_has_device_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceOption::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceOption::clear_device_type() {
  device_type_ = 0;
  clear_has_device_type();
}
inline ::google::protobuf::int32 DeviceOption::device_type() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.device_type)
  return device_type_;
}
inline void DeviceOption::set_device_type(::google::protobuf::int32 value) {
  set_has_device_type();
  device_type_ = value;
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.device_type)
}

// optional int32 device_id = 2;
inline bool DeviceOption::has_device_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceOption::set_has_device_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceOption::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceOption::clear_device_id() {
  device_id_ = 0;
  clear_has_device_id();
}
inline ::google::protobuf::int32 DeviceOption::device_id() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.device_id)
  return device_id_;
}
inline void DeviceOption::set_device_id(::google::protobuf::int32 value) {
  set_has_device_id();
  device_id_ = value;
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.device_id)
}

// optional uint32 random_seed = 3;
inline bool DeviceOption::has_random_seed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceOption::set_has_random_seed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceOption::clear_has_random_seed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceOption::clear_random_seed() {
  random_seed_ = 0u;
  clear_has_random_seed();
}
inline ::google::protobuf::uint32 DeviceOption::random_seed() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.random_seed)
  return random_seed_;
}
inline void DeviceOption::set_random_seed(::google::protobuf::uint32 value) {
  set_has_random_seed();
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.random_seed)
}

// optional string node_name = 4;
inline bool DeviceOption::has_node_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceOption::set_has_node_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceOption::clear_has_node_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceOption::clear_node_name() {
  node_name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_node_name();
}
inline const ::std::string& DeviceOption::node_name() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.node_name)
  return node_name_.GetNoArena();
}
inline void DeviceOption::set_node_name(const ::std::string& value) {
  set_has_node_name();
  node_name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.node_name)
}
#if LANG_CXX11
inline void DeviceOption::set_node_name(::std::string&& value) {
  set_has_node_name();
  node_name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DeviceOption.node_name)
}
#endif
inline void DeviceOption::set_node_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_name();
  node_name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DeviceOption.node_name)
}
inline void DeviceOption::set_node_name(const char* value, size_t size) {
  set_has_node_name();
  node_name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DeviceOption.node_name)
}
inline ::std::string* DeviceOption::mutable_node_name() {
  set_has_node_name();
  // @@protoc_insertion_point(field_mutable:caffe2.DeviceOption.node_name)
  return node_name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceOption::release_node_name() {
  // @@protoc_insertion_point(field_release:caffe2.DeviceOption.node_name)
  clear_has_node_name();
  return node_name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void DeviceOption::set_allocated_node_name(::std::string* node_name) {
  if (node_name != NULL) {
    set_has_node_name();
  } else {
    clear_has_node_name();
  }
  node_name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), node_name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DeviceOption.node_name)
}

// optional int32 numa_node_id = 5;
inline bool DeviceOption::has_numa_node_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceOption::set_has_numa_node_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceOption::clear_has_numa_node_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceOption::clear_numa_node_id() {
  numa_node_id_ = 0;
  clear_has_numa_node_id();
}
inline ::google::protobuf::int32 DeviceOption::numa_node_id() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.numa_node_id)
  return numa_node_id_;
}
inline void DeviceOption::set_numa_node_id(::google::protobuf::int32 value) {
  set_has_numa_node_id();
  numa_node_id_ = value;
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.numa_node_id)
}

// repeated string extra_info = 6;
inline int DeviceOption::extra_info_size() const {
  return extra_info_.size();
}
inline void DeviceOption::clear_extra_info() {
  extra_info_.Clear();
}
inline const ::std::string& DeviceOption::extra_info(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.extra_info)
  return extra_info_.Get(index);
}
inline ::std::string* DeviceOption::mutable_extra_info(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.DeviceOption.extra_info)
  return extra_info_.Mutable(index);
}
inline void DeviceOption::set_extra_info(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.extra_info)
  extra_info_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeviceOption::set_extra_info(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.extra_info)
  extra_info_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeviceOption::set_extra_info(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  extra_info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.DeviceOption.extra_info)
}
inline void DeviceOption::set_extra_info(int index, const char* value, size_t size) {
  extra_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.DeviceOption.extra_info)
}
inline ::std::string* DeviceOption::add_extra_info() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.DeviceOption.extra_info)
  return extra_info_.Add();
}
inline void DeviceOption::add_extra_info(const ::std::string& value) {
  extra_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.DeviceOption.extra_info)
}
#if LANG_CXX11
inline void DeviceOption::add_extra_info(::std::string&& value) {
  extra_info_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.DeviceOption.extra_info)
}
#endif
inline void DeviceOption::add_extra_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  extra_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.DeviceOption.extra_info)
}
inline void DeviceOption::add_extra_info(const char* value, size_t size) {
  extra_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.DeviceOption.extra_info)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeviceOption::extra_info() const {
  // @@protoc_insertion_point(field_list:caffe2.DeviceOption.extra_info)
  return extra_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeviceOption::mutable_extra_info() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.DeviceOption.extra_info)
  return &extra_info_;
}

// -------------------------------------------------------------------

// OperatorDef

// repeated string input = 1;
inline int OperatorDef::input_size() const {
  return input_.size();
}
inline void OperatorDef::clear_input() {
  input_.Clear();
}
inline const ::std::string& OperatorDef::input(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.input)
  return input_.Get(index);
}
inline ::std::string* OperatorDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.input)
  return input_.Mutable(index);
}
inline void OperatorDef::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.input)
  input_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperatorDef::set_input(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.input)
  input_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperatorDef::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.input)
}
inline void OperatorDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.input)
}
inline ::std::string* OperatorDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OperatorDef.input)
  return input_.Add();
}
inline void OperatorDef::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.input)
}
#if LANG_CXX11
inline void OperatorDef::add_input(::std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.input)
}
#endif
inline void OperatorDef::add_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OperatorDef.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::input() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.input)
  return &input_;
}

// repeated string output = 2;
inline int OperatorDef::output_size() const {
  return output_.size();
}
inline void OperatorDef::clear_output() {
  output_.Clear();
}
inline const ::std::string& OperatorDef::output(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.output)
  return output_.Get(index);
}
inline ::std::string* OperatorDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.output)
  return output_.Mutable(index);
}
inline void OperatorDef::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.output)
  output_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperatorDef::set_output(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.output)
  output_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperatorDef::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.output)
}
inline void OperatorDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.output)
}
inline ::std::string* OperatorDef::add_output() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OperatorDef.output)
  return output_.Add();
}
inline void OperatorDef::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.output)
}
#if LANG_CXX11
inline void OperatorDef::add_output(::std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.output)
}
#endif
inline void OperatorDef::add_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OperatorDef.output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::output() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.output)
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.output)
  return &output_;
}

// optional string name = 3;
inline bool OperatorDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperatorDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperatorDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperatorDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OperatorDef::name() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.name)
  return name_.GetNoArena();
}
inline void OperatorDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.name)
}
#if LANG_CXX11
inline void OperatorDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.name)
}
#endif
inline void OperatorDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.name)
}
inline ::std::string* OperatorDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.name)
}

// optional string type = 4;
inline bool OperatorDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperatorDef::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperatorDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperatorDef::clear_type() {
  type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& OperatorDef::type() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.type)
  return type_.GetNoArena();
}
inline void OperatorDef::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.type)
}
#if LANG_CXX11
inline void OperatorDef::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.type)
}
#endif
inline void OperatorDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.type)
}
inline ::std::string* OperatorDef::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.type)
  return type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_type() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.type)
  clear_has_type();
  return type_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.type)
}

// repeated .caffe2.Argument arg = 5;
inline int OperatorDef::arg_size() const {
  return arg_.size();
}
inline void OperatorDef::clear_arg() {
  arg_.Clear();
}
inline const ::caffe2::Argument& OperatorDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.arg)
  return arg_.Get(index);
}
inline ::caffe2::Argument* OperatorDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.arg)
  return arg_.Mutable(index);
}
inline ::caffe2::Argument* OperatorDef::add_arg() {
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >*
OperatorDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >&
OperatorDef::arg() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.arg)
  return arg_;
}

// optional .caffe2.DeviceOption device_option = 6;
inline bool OperatorDef::has_device_option() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperatorDef::set_has_device_option() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperatorDef::clear_has_device_option() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperatorDef::clear_device_option() {
  if (device_option_ != NULL) device_option_->Clear();
  clear_has_device_option();
}
inline const ::caffe2::DeviceOption& OperatorDef::device_option() const {
  const ::caffe2::DeviceOption* p = device_option_;
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.device_option)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::DeviceOption*>(
      &::caffe2::_DeviceOption_default_instance_);
}
inline ::caffe2::DeviceOption* OperatorDef::release_device_option() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.device_option)
  clear_has_device_option();
  ::caffe2::DeviceOption* temp = device_option_;
  device_option_ = NULL;
  return temp;
}
inline ::caffe2::DeviceOption* OperatorDef::mutable_device_option() {
  set_has_device_option();
  if (device_option_ == NULL) {
    device_option_ = new ::caffe2::DeviceOption;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.device_option)
  return device_option_;
}
inline void OperatorDef::set_allocated_device_option(::caffe2::DeviceOption* device_option) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_option_;
  }
  if (device_option) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_option = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_option, submessage_arena);
    }
    set_has_device_option();
  } else {
    clear_has_device_option();
  }
  device_option_ = device_option;
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.device_option)
}

// optional string engine = 7;
inline bool OperatorDef::has_engine() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperatorDef::set_has_engine() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperatorDef::clear_has_engine() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperatorDef::clear_engine() {
  engine_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_engine();
}
inline const ::std::string& OperatorDef::engine() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.engine)
  return engine_.GetNoArena();
}
inline void OperatorDef::set_engine(const ::std::string& value) {
  set_has_engine();
  engine_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.engine)
}
#if LANG_CXX11
inline void OperatorDef::set_engine(::std::string&& value) {
  set_has_engine();
  engine_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.engine)
}
#endif
inline void OperatorDef::set_engine(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_engine();
  engine_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.engine)
}
inline void OperatorDef::set_engine(const char* value, size_t size) {
  set_has_engine();
  engine_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.engine)
}
inline ::std::string* OperatorDef::mutable_engine() {
  set_has_engine();
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.engine)
  return engine_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_engine() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.engine)
  clear_has_engine();
  return engine_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_engine(::std::string* engine) {
  if (engine != NULL) {
    set_has_engine();
  } else {
    clear_has_engine();
  }
  engine_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), engine);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.engine)
}

// repeated string control_input = 8;
inline int OperatorDef::control_input_size() const {
  return control_input_.size();
}
inline void OperatorDef::clear_control_input() {
  control_input_.Clear();
}
inline const ::std::string& OperatorDef::control_input(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.control_input)
  return control_input_.Get(index);
}
inline ::std::string* OperatorDef::mutable_control_input(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.control_input)
  return control_input_.Mutable(index);
}
inline void OperatorDef::set_control_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.control_input)
  control_input_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperatorDef::set_control_input(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.control_input)
  control_input_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperatorDef::set_control_input(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  control_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.control_input)
}
inline void OperatorDef::set_control_input(int index, const char* value, size_t size) {
  control_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.control_input)
}
inline ::std::string* OperatorDef::add_control_input() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OperatorDef.control_input)
  return control_input_.Add();
}
inline void OperatorDef::add_control_input(const ::std::string& value) {
  control_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.control_input)
}
#if LANG_CXX11
inline void OperatorDef::add_control_input(::std::string&& value) {
  control_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.control_input)
}
#endif
inline void OperatorDef::add_control_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  control_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OperatorDef.control_input)
}
inline void OperatorDef::add_control_input(const char* value, size_t size) {
  control_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OperatorDef.control_input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::control_input() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.control_input)
  return control_input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_control_input() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.control_input)
  return &control_input_;
}

// optional bool is_gradient_op = 9 [default = false];
inline bool OperatorDef::has_is_gradient_op() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OperatorDef::set_has_is_gradient_op() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OperatorDef::clear_has_is_gradient_op() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OperatorDef::clear_is_gradient_op() {
  is_gradient_op_ = false;
  clear_has_is_gradient_op();
}
inline bool OperatorDef::is_gradient_op() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.is_gradient_op)
  return is_gradient_op_;
}
inline void OperatorDef::set_is_gradient_op(bool value) {
  set_has_is_gradient_op();
  is_gradient_op_ = value;
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.is_gradient_op)
}

// optional string debug_info = 10;
inline bool OperatorDef::has_debug_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperatorDef::set_has_debug_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperatorDef::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperatorDef::clear_debug_info() {
  debug_info_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_debug_info();
}
inline const ::std::string& OperatorDef::debug_info() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.debug_info)
  return debug_info_.GetNoArena();
}
inline void OperatorDef::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  debug_info_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.debug_info)
}
#if LANG_CXX11
inline void OperatorDef::set_debug_info(::std::string&& value) {
  set_has_debug_info();
  debug_info_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.debug_info)
}
#endif
inline void OperatorDef::set_debug_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_debug_info();
  debug_info_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.debug_info)
}
inline void OperatorDef::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  debug_info_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.debug_info)
}
inline ::std::string* OperatorDef::mutable_debug_info() {
  set_has_debug_info();
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.debug_info)
  return debug_info_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_debug_info() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.debug_info)
  clear_has_debug_info();
  return debug_info_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info != NULL) {
    set_has_debug_info();
  } else {
    clear_has_debug_info();
  }
  debug_info_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), debug_info);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.debug_info)
}

// optional string domain = 11;
inline bool OperatorDef::has_domain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperatorDef::set_has_domain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperatorDef::clear_has_domain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperatorDef::clear_domain() {
  domain_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_domain();
}
inline const ::std::string& OperatorDef::domain() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.domain)
  return domain_.GetNoArena();
}
inline void OperatorDef::set_domain(const ::std::string& value) {
  set_has_domain();
  domain_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.domain)
}
#if LANG_CXX11
inline void OperatorDef::set_domain(::std::string&& value) {
  set_has_domain();
  domain_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.domain)
}
#endif
inline void OperatorDef::set_domain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_domain();
  domain_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.domain)
}
inline void OperatorDef::set_domain(const char* value, size_t size) {
  set_has_domain();
  domain_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.domain)
}
inline ::std::string* OperatorDef::mutable_domain() {
  set_has_domain();
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.domain)
  return domain_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_domain() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.domain)
  clear_has_domain();
  return domain_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    set_has_domain();
  } else {
    clear_has_domain();
  }
  domain_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.domain)
}

// optional int64 op_version = 12;
inline bool OperatorDef::has_op_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OperatorDef::set_has_op_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OperatorDef::clear_has_op_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OperatorDef::clear_op_version() {
  op_version_ = GOOGLE_LONGLONG(0);
  clear_has_op_version();
}
inline ::google::protobuf::int64 OperatorDef::op_version() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.op_version)
  return op_version_;
}
inline void OperatorDef::set_op_version(::google::protobuf::int64 value) {
  set_has_op_version();
  op_version_ = value;
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.op_version)
}

// -------------------------------------------------------------------

// NetDef

// optional string name = 1;
inline bool NetDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& NetDef::name() const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.name)
  return name_.GetNoArena();
}
inline void NetDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.NetDef.name)
}
#if LANG_CXX11
inline void NetDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.NetDef.name)
}
#endif
inline void NetDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.name)
}
inline void NetDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.name)
}
inline ::std::string* NetDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDef::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.NetDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetDef.name)
}

// repeated .caffe2.OperatorDef op = 2;
inline int NetDef::op_size() const {
  return op_.size();
}
inline void NetDef::clear_op() {
  op_.Clear();
}
inline const ::caffe2::OperatorDef& NetDef::op(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.op)
  return op_.Get(index);
}
inline ::caffe2::OperatorDef* NetDef::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.op)
  return op_.Mutable(index);
}
inline ::caffe2::OperatorDef* NetDef::add_op() {
  // @@protoc_insertion_point(field_add:caffe2.NetDef.op)
  return op_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::OperatorDef >*
NetDef::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.op)
  return &op_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::OperatorDef >&
NetDef::op() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.op)
  return op_;
}

// optional string type = 3;
inline bool NetDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetDef::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetDef::clear_type() {
  type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& NetDef::type() const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.type)
  return type_.GetNoArena();
}
inline void NetDef::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.NetDef.type)
}
#if LANG_CXX11
inline void NetDef::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.NetDef.type)
}
#endif
inline void NetDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.type)
}
inline void NetDef::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.type)
}
inline ::std::string* NetDef::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.type)
  return type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDef::release_type() {
  // @@protoc_insertion_point(field_release:caffe2.NetDef.type)
  clear_has_type();
  return type_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetDef.type)
}

// optional int32 num_workers = 4 [deprecated = true];
inline bool NetDef::has_num_workers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetDef::set_has_num_workers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetDef::clear_has_num_workers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetDef::clear_num_workers() {
  num_workers_ = 0;
  clear_has_num_workers();
}
inline ::google::protobuf::int32 NetDef::num_workers() const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.num_workers)
  return num_workers_;
}
inline void NetDef::set_num_workers(::google::protobuf::int32 value) {
  set_has_num_workers();
  num_workers_ = value;
  // @@protoc_insertion_point(field_set:caffe2.NetDef.num_workers)
}

// optional .caffe2.DeviceOption device_option = 5;
inline bool NetDef::has_device_option() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetDef::set_has_device_option() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetDef::clear_has_device_option() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetDef::clear_device_option() {
  if (device_option_ != NULL) device_option_->Clear();
  clear_has_device_option();
}
inline const ::caffe2::DeviceOption& NetDef::device_option() const {
  const ::caffe2::DeviceOption* p = device_option_;
  // @@protoc_insertion_point(field_get:caffe2.NetDef.device_option)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::DeviceOption*>(
      &::caffe2::_DeviceOption_default_instance_);
}
inline ::caffe2::DeviceOption* NetDef::release_device_option() {
  // @@protoc_insertion_point(field_release:caffe2.NetDef.device_option)
  clear_has_device_option();
  ::caffe2::DeviceOption* temp = device_option_;
  device_option_ = NULL;
  return temp;
}
inline ::caffe2::DeviceOption* NetDef::mutable_device_option() {
  set_has_device_option();
  if (device_option_ == NULL) {
    device_option_ = new ::caffe2::DeviceOption;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.device_option)
  return device_option_;
}
inline void NetDef::set_allocated_device_option(::caffe2::DeviceOption* device_option) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_option_;
  }
  if (device_option) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_option = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_option, submessage_arena);
    }
    set_has_device_option();
  } else {
    clear_has_device_option();
  }
  device_option_ = device_option;
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetDef.device_option)
}

// repeated .caffe2.Argument arg = 6;
inline int NetDef::arg_size() const {
  return arg_.size();
}
inline void NetDef::clear_arg() {
  arg_.Clear();
}
inline const ::caffe2::Argument& NetDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.arg)
  return arg_.Get(index);
}
inline ::caffe2::Argument* NetDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.arg)
  return arg_.Mutable(index);
}
inline ::caffe2::Argument* NetDef::add_arg() {
  // @@protoc_insertion_point(field_add:caffe2.NetDef.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >*
NetDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::Argument >&
NetDef::arg() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.arg)
  return arg_;
}

// repeated string external_input = 7;
inline int NetDef::external_input_size() const {
  return external_input_.size();
}
inline void NetDef::clear_external_input() {
  external_input_.Clear();
}
inline const ::std::string& NetDef::external_input(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.external_input)
  return external_input_.Get(index);
}
inline ::std::string* NetDef::mutable_external_input(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.external_input)
  return external_input_.Mutable(index);
}
inline void NetDef::set_external_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_input)
  external_input_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetDef::set_external_input(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_input)
  external_input_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetDef::set_external_input(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  external_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.external_input)
}
inline void NetDef::set_external_input(int index, const char* value, size_t size) {
  external_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.external_input)
}
inline ::std::string* NetDef::add_external_input() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.NetDef.external_input)
  return external_input_.Add();
}
inline void NetDef::add_external_input(const ::std::string& value) {
  external_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_input)
}
#if LANG_CXX11
inline void NetDef::add_external_input(::std::string&& value) {
  external_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_input)
}
#endif
inline void NetDef::add_external_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  external_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.NetDef.external_input)
}
inline void NetDef::add_external_input(const char* value, size_t size) {
  external_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.NetDef.external_input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetDef::external_input() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.external_input)
  return external_input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetDef::mutable_external_input() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.external_input)
  return &external_input_;
}

// repeated string external_output = 8;
inline int NetDef::external_output_size() const {
  return external_output_.size();
}
inline void NetDef::clear_external_output() {
  external_output_.Clear();
}
inline const ::std::string& NetDef::external_output(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.external_output)
  return external_output_.Get(index);
}
inline ::std::string* NetDef::mutable_external_output(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.external_output)
  return external_output_.Mutable(index);
}
inline void NetDef::set_external_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_output)
  external_output_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetDef::set_external_output(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_output)
  external_output_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetDef::set_external_output(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  external_output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.external_output)
}
inline void NetDef::set_external_output(int index, const char* value, size_t size) {
  external_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.external_output)
}
inline ::std::string* NetDef::add_external_output() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.NetDef.external_output)
  return external_output_.Add();
}
inline void NetDef::add_external_output(const ::std::string& value) {
  external_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_output)
}
#if LANG_CXX11
inline void NetDef::add_external_output(::std::string&& value) {
  external_output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_output)
}
#endif
inline void NetDef::add_external_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  external_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.NetDef.external_output)
}
inline void NetDef::add_external_output(const char* value, size_t size) {
  external_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.NetDef.external_output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetDef::external_output() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.external_output)
  return external_output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetDef::mutable_external_output() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.external_output)
  return &external_output_;
}

// -------------------------------------------------------------------

// ExecutionStep

// optional string name = 1;
inline bool ExecutionStep::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutionStep::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutionStep::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutionStep::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ExecutionStep::name() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.name)
  return name_.GetNoArena();
}
inline void ExecutionStep::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.name)
}
#if LANG_CXX11
inline void ExecutionStep::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.name)
}
#endif
inline void ExecutionStep::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.name)
}
inline void ExecutionStep::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.name)
}
inline ::std::string* ExecutionStep::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecutionStep::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.name)
}

// repeated .caffe2.ExecutionStep substep = 2;
inline int ExecutionStep::substep_size() const {
  return substep_.size();
}
inline void ExecutionStep::clear_substep() {
  substep_.Clear();
}
inline const ::caffe2::ExecutionStep& ExecutionStep::substep(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.substep)
  return substep_.Get(index);
}
inline ::caffe2::ExecutionStep* ExecutionStep::mutable_substep(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.substep)
  return substep_.Mutable(index);
}
inline ::caffe2::ExecutionStep* ExecutionStep::add_substep() {
  // @@protoc_insertion_point(field_add:caffe2.ExecutionStep.substep)
  return substep_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >*
ExecutionStep::mutable_substep() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.ExecutionStep.substep)
  return &substep_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >&
ExecutionStep::substep() const {
  // @@protoc_insertion_point(field_list:caffe2.ExecutionStep.substep)
  return substep_;
}

// repeated string network = 3;
inline int ExecutionStep::network_size() const {
  return network_.size();
}
inline void ExecutionStep::clear_network() {
  network_.Clear();
}
inline const ::std::string& ExecutionStep::network(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.network)
  return network_.Get(index);
}
inline ::std::string* ExecutionStep::mutable_network(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.network)
  return network_.Mutable(index);
}
inline void ExecutionStep::set_network(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.network)
  network_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ExecutionStep::set_network(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.network)
  network_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ExecutionStep::set_network(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  network_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.network)
}
inline void ExecutionStep::set_network(int index, const char* value, size_t size) {
  network_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.network)
}
inline ::std::string* ExecutionStep::add_network() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.ExecutionStep.network)
  return network_.Add();
}
inline void ExecutionStep::add_network(const ::std::string& value) {
  network_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.ExecutionStep.network)
}
#if LANG_CXX11
inline void ExecutionStep::add_network(::std::string&& value) {
  network_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.ExecutionStep.network)
}
#endif
inline void ExecutionStep::add_network(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  network_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.ExecutionStep.network)
}
inline void ExecutionStep::add_network(const char* value, size_t size) {
  network_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.ExecutionStep.network)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExecutionStep::network() const {
  // @@protoc_insertion_point(field_list:caffe2.ExecutionStep.network)
  return network_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExecutionStep::mutable_network() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.ExecutionStep.network)
  return &network_;
}

// optional int64 num_iter = 4;
inline bool ExecutionStep::has_num_iter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutionStep::set_has_num_iter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutionStep::clear_has_num_iter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutionStep::clear_num_iter() {
  num_iter_ = GOOGLE_LONGLONG(0);
  clear_has_num_iter();
}
inline ::google::protobuf::int64 ExecutionStep::num_iter() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.num_iter)
  return num_iter_;
}
inline void ExecutionStep::set_num_iter(::google::protobuf::int64 value) {
  set_has_num_iter();
  num_iter_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.num_iter)
}

// optional string criteria_network = 5 [deprecated = true];
inline bool ExecutionStep::has_criteria_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutionStep::set_has_criteria_network() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutionStep::clear_has_criteria_network() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutionStep::clear_criteria_network() {
  criteria_network_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_criteria_network();
}
inline const ::std::string& ExecutionStep::criteria_network() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.criteria_network)
  return criteria_network_.GetNoArena();
}
inline void ExecutionStep::set_criteria_network(const ::std::string& value) {
  set_has_criteria_network();
  criteria_network_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.criteria_network)
}
#if LANG_CXX11
inline void ExecutionStep::set_criteria_network(::std::string&& value) {
  set_has_criteria_network();
  criteria_network_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.criteria_network)
}
#endif
inline void ExecutionStep::set_criteria_network(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_criteria_network();
  criteria_network_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.criteria_network)
}
inline void ExecutionStep::set_criteria_network(const char* value, size_t size) {
  set_has_criteria_network();
  criteria_network_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.criteria_network)
}
inline ::std::string* ExecutionStep::mutable_criteria_network() {
  set_has_criteria_network();
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.criteria_network)
  return criteria_network_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecutionStep::release_criteria_network() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.criteria_network)
  clear_has_criteria_network();
  return criteria_network_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_criteria_network(::std::string* criteria_network) {
  if (criteria_network != NULL) {
    set_has_criteria_network();
  } else {
    clear_has_criteria_network();
  }
  criteria_network_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), criteria_network);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.criteria_network)
}

// optional string report_net = 7;
inline bool ExecutionStep::has_report_net() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutionStep::set_has_report_net() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutionStep::clear_has_report_net() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutionStep::clear_report_net() {
  report_net_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_report_net();
}
inline const ::std::string& ExecutionStep::report_net() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.report_net)
  return report_net_.GetNoArena();
}
inline void ExecutionStep::set_report_net(const ::std::string& value) {
  set_has_report_net();
  report_net_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.report_net)
}
#if LANG_CXX11
inline void ExecutionStep::set_report_net(::std::string&& value) {
  set_has_report_net();
  report_net_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.report_net)
}
#endif
inline void ExecutionStep::set_report_net(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_report_net();
  report_net_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.report_net)
}
inline void ExecutionStep::set_report_net(const char* value, size_t size) {
  set_has_report_net();
  report_net_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.report_net)
}
inline ::std::string* ExecutionStep::mutable_report_net() {
  set_has_report_net();
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.report_net)
  return report_net_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecutionStep::release_report_net() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.report_net)
  clear_has_report_net();
  return report_net_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_report_net(::std::string* report_net) {
  if (report_net != NULL) {
    set_has_report_net();
  } else {
    clear_has_report_net();
  }
  report_net_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), report_net);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.report_net)
}

// optional int32 report_interval = 8;
inline bool ExecutionStep::has_report_interval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutionStep::set_has_report_interval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutionStep::clear_has_report_interval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutionStep::clear_report_interval() {
  report_interval_ = 0;
  clear_has_report_interval();
}
inline ::google::protobuf::int32 ExecutionStep::report_interval() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.report_interval)
  return report_interval_;
}
inline void ExecutionStep::set_report_interval(::google::protobuf::int32 value) {
  set_has_report_interval();
  report_interval_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.report_interval)
}

// optional int64 run_every_ms = 11;
inline bool ExecutionStep::has_run_every_ms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExecutionStep::set_has_run_every_ms() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExecutionStep::clear_has_run_every_ms() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExecutionStep::clear_run_every_ms() {
  run_every_ms_ = GOOGLE_LONGLONG(0);
  clear_has_run_every_ms();
}
inline ::google::protobuf::int64 ExecutionStep::run_every_ms() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.run_every_ms)
  return run_every_ms_;
}
inline void ExecutionStep::set_run_every_ms(::google::protobuf::int64 value) {
  set_has_run_every_ms();
  run_every_ms_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.run_every_ms)
}

// optional bool concurrent_substeps = 6;
inline bool ExecutionStep::has_concurrent_substeps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutionStep::set_has_concurrent_substeps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutionStep::clear_has_concurrent_substeps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutionStep::clear_concurrent_substeps() {
  concurrent_substeps_ = false;
  clear_has_concurrent_substeps();
}
inline bool ExecutionStep::concurrent_substeps() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.concurrent_substeps)
  return concurrent_substeps_;
}
inline void ExecutionStep::set_concurrent_substeps(bool value) {
  set_has_concurrent_substeps();
  concurrent_substeps_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.concurrent_substeps)
}

// optional string should_stop_blob = 9;
inline bool ExecutionStep::has_should_stop_blob() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutionStep::set_has_should_stop_blob() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutionStep::clear_has_should_stop_blob() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutionStep::clear_should_stop_blob() {
  should_stop_blob_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_should_stop_blob();
}
inline const ::std::string& ExecutionStep::should_stop_blob() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.should_stop_blob)
  return should_stop_blob_.GetNoArena();
}
inline void ExecutionStep::set_should_stop_blob(const ::std::string& value) {
  set_has_should_stop_blob();
  should_stop_blob_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.should_stop_blob)
}
#if LANG_CXX11
inline void ExecutionStep::set_should_stop_blob(::std::string&& value) {
  set_has_should_stop_blob();
  should_stop_blob_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.should_stop_blob)
}
#endif
inline void ExecutionStep::set_should_stop_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_should_stop_blob();
  should_stop_blob_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.should_stop_blob)
}
inline void ExecutionStep::set_should_stop_blob(const char* value, size_t size) {
  set_has_should_stop_blob();
  should_stop_blob_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.should_stop_blob)
}
inline ::std::string* ExecutionStep::mutable_should_stop_blob() {
  set_has_should_stop_blob();
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.should_stop_blob)
  return should_stop_blob_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecutionStep::release_should_stop_blob() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.should_stop_blob)
  clear_has_should_stop_blob();
  return should_stop_blob_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_should_stop_blob(::std::string* should_stop_blob) {
  if (should_stop_blob != NULL) {
    set_has_should_stop_blob();
  } else {
    clear_has_should_stop_blob();
  }
  should_stop_blob_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), should_stop_blob);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.should_stop_blob)
}

// optional bool only_once = 10;
inline bool ExecutionStep::has_only_once() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecutionStep::set_has_only_once() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecutionStep::clear_has_only_once() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecutionStep::clear_only_once() {
  only_once_ = false;
  clear_has_only_once();
}
inline bool ExecutionStep::only_once() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.only_once)
  return only_once_;
}
inline void ExecutionStep::set_only_once(bool value) {
  set_has_only_once();
  only_once_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.only_once)
}

// optional bool create_workspace = 12;
inline bool ExecutionStep::has_create_workspace() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutionStep::set_has_create_workspace() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutionStep::clear_has_create_workspace() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutionStep::clear_create_workspace() {
  create_workspace_ = false;
  clear_has_create_workspace();
}
inline bool ExecutionStep::create_workspace() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.create_workspace)
  return create_workspace_;
}
inline void ExecutionStep::set_create_workspace(bool value) {
  set_has_create_workspace();
  create_workspace_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.create_workspace)
}

// optional int32 num_concurrent_instances = 13;
inline bool ExecutionStep::has_num_concurrent_instances() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExecutionStep::set_has_num_concurrent_instances() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExecutionStep::clear_has_num_concurrent_instances() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExecutionStep::clear_num_concurrent_instances() {
  num_concurrent_instances_ = 0;
  clear_has_num_concurrent_instances();
}
inline ::google::protobuf::int32 ExecutionStep::num_concurrent_instances() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.num_concurrent_instances)
  return num_concurrent_instances_;
}
inline void ExecutionStep::set_num_concurrent_instances(::google::protobuf::int32 value) {
  set_has_num_concurrent_instances();
  num_concurrent_instances_ = value;
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.num_concurrent_instances)
}

// -------------------------------------------------------------------

// PlanDef

// optional string name = 1;
inline bool PlanDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PlanDef::name() const {
  // @@protoc_insertion_point(field_get:caffe2.PlanDef.name)
  return name_.GetNoArena();
}
inline void PlanDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.PlanDef.name)
}
#if LANG_CXX11
inline void PlanDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.PlanDef.name)
}
#endif
inline void PlanDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.PlanDef.name)
}
inline void PlanDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.PlanDef.name)
}
inline ::std::string* PlanDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.PlanDef.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* PlanDef::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.PlanDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void PlanDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlanDef.name)
}

// repeated .caffe2.NetDef network = 2;
inline int PlanDef::network_size() const {
  return network_.size();
}
inline void PlanDef::clear_network() {
  network_.Clear();
}
inline const ::caffe2::NetDef& PlanDef::network(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.PlanDef.network)
  return network_.Get(index);
}
inline ::caffe2::NetDef* PlanDef::mutable_network(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.PlanDef.network)
  return network_.Mutable(index);
}
inline ::caffe2::NetDef* PlanDef::add_network() {
  // @@protoc_insertion_point(field_add:caffe2.PlanDef.network)
  return network_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >*
PlanDef::mutable_network() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.PlanDef.network)
  return &network_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >&
PlanDef::network() const {
  // @@protoc_insertion_point(field_list:caffe2.PlanDef.network)
  return network_;
}

// repeated .caffe2.ExecutionStep execution_step = 3;
inline int PlanDef::execution_step_size() const {
  return execution_step_.size();
}
inline void PlanDef::clear_execution_step() {
  execution_step_.Clear();
}
inline const ::caffe2::ExecutionStep& PlanDef::execution_step(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.PlanDef.execution_step)
  return execution_step_.Get(index);
}
inline ::caffe2::ExecutionStep* PlanDef::mutable_execution_step(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.PlanDef.execution_step)
  return execution_step_.Mutable(index);
}
inline ::caffe2::ExecutionStep* PlanDef::add_execution_step() {
  // @@protoc_insertion_point(field_add:caffe2.PlanDef.execution_step)
  return execution_step_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >*
PlanDef::mutable_execution_step() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.PlanDef.execution_step)
  return &execution_step_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::ExecutionStep >&
PlanDef::execution_step() const {
  // @@protoc_insertion_point(field_list:caffe2.PlanDef.execution_step)
  return execution_step_;
}

// -------------------------------------------------------------------

// BlobProto

// optional string name = 1;
inline bool BlobProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& BlobProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.name)
  return name_.GetNoArena();
}
inline void BlobProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.name)
}
#if LANG_CXX11
inline void BlobProto::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobProto.name)
}
#endif
inline void BlobProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobProto.name)
}
inline void BlobProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobProto.name)
}
inline ::std::string* BlobProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* BlobProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void BlobProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.name)
}

// optional string type = 2;
inline bool BlobProto::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobProto::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobProto::clear_type() {
  type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& BlobProto::type() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.type)
  return type_.GetNoArena();
}
inline void BlobProto::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.type)
}
#if LANG_CXX11
inline void BlobProto::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobProto.type)
}
#endif
inline void BlobProto::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobProto.type)
}
inline void BlobProto::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobProto.type)
}
inline ::std::string* BlobProto::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.type)
  return type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* BlobProto::release_type() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.type)
  clear_has_type();
  return type_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void BlobProto::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.type)
}

// optional .caffe2.TensorProto tensor = 3;
inline bool BlobProto::has_tensor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlobProto::set_has_tensor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlobProto::clear_has_tensor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlobProto::clear_tensor() {
  if (tensor_ != NULL) tensor_->Clear();
  clear_has_tensor();
}
inline const ::caffe2::TensorProto& BlobProto::tensor() const {
  const ::caffe2::TensorProto* p = tensor_;
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.tensor)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::TensorProto*>(
      &::caffe2::_TensorProto_default_instance_);
}
inline ::caffe2::TensorProto* BlobProto::release_tensor() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.tensor)
  clear_has_tensor();
  ::caffe2::TensorProto* temp = tensor_;
  tensor_ = NULL;
  return temp;
}
inline ::caffe2::TensorProto* BlobProto::mutable_tensor() {
  set_has_tensor();
  if (tensor_ == NULL) {
    tensor_ = new ::caffe2::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.tensor)
  return tensor_;
}
inline void BlobProto::set_allocated_tensor(::caffe2::TensorProto* tensor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tensor_;
  }
  if (tensor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    set_has_tensor();
  } else {
    clear_has_tensor();
  }
  tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.tensor)
}

// optional bytes content = 4;
inline bool BlobProto::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobProto::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobProto::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobProto::clear_content() {
  content_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& BlobProto::content() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.content)
  return content_.GetNoArena();
}
inline void BlobProto::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.content)
}
#if LANG_CXX11
inline void BlobProto::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobProto.content)
}
#endif
inline void BlobProto::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobProto.content)
}
inline void BlobProto::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobProto.content)
}
inline ::std::string* BlobProto::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.content)
  return content_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* BlobProto::release_content() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.content)
  clear_has_content();
  return content_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void BlobProto::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.content)
}

// optional .caffe2.QTensorProto qtensor = 5;
inline bool BlobProto::has_qtensor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlobProto::set_has_qtensor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlobProto::clear_has_qtensor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlobProto::clear_qtensor() {
  if (qtensor_ != NULL) qtensor_->Clear();
  clear_has_qtensor();
}
inline const ::caffe2::QTensorProto& BlobProto::qtensor() const {
  const ::caffe2::QTensorProto* p = qtensor_;
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.qtensor)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::QTensorProto*>(
      &::caffe2::_QTensorProto_default_instance_);
}
inline ::caffe2::QTensorProto* BlobProto::release_qtensor() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.qtensor)
  clear_has_qtensor();
  ::caffe2::QTensorProto* temp = qtensor_;
  qtensor_ = NULL;
  return temp;
}
inline ::caffe2::QTensorProto* BlobProto::mutable_qtensor() {
  set_has_qtensor();
  if (qtensor_ == NULL) {
    qtensor_ = new ::caffe2::QTensorProto;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.qtensor)
  return qtensor_;
}
inline void BlobProto::set_allocated_qtensor(::caffe2::QTensorProto* qtensor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete qtensor_;
  }
  if (qtensor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      qtensor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, qtensor, submessage_arena);
    }
    set_has_qtensor();
  } else {
    clear_has_qtensor();
  }
  qtensor_ = qtensor;
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.qtensor)
}

// optional int32 content_num_chunks = 6;
inline bool BlobProto::has_content_num_chunks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlobProto::set_has_content_num_chunks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlobProto::clear_has_content_num_chunks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlobProto::clear_content_num_chunks() {
  content_num_chunks_ = 0;
  clear_has_content_num_chunks();
}
inline ::google::protobuf::int32 BlobProto::content_num_chunks() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.content_num_chunks)
  return content_num_chunks_;
}
inline void BlobProto::set_content_num_chunks(::google::protobuf::int32 value) {
  set_has_content_num_chunks();
  content_num_chunks_ = value;
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.content_num_chunks)
}

// optional int32 content_chunk_id = 7;
inline bool BlobProto::has_content_chunk_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlobProto::set_has_content_chunk_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlobProto::clear_has_content_chunk_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlobProto::clear_content_chunk_id() {
  content_chunk_id_ = 0;
  clear_has_content_chunk_id();
}
inline ::google::protobuf::int32 BlobProto::content_chunk_id() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.content_chunk_id)
  return content_chunk_id_;
}
inline void BlobProto::set_content_chunk_id(::google::protobuf::int32 value) {
  set_has_content_chunk_id();
  content_chunk_id_ = value;
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.content_chunk_id)
}

// -------------------------------------------------------------------

// DBReaderProto

// optional string name = 1;
inline bool DBReaderProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBReaderProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBReaderProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBReaderProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DBReaderProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.name)
  return name_.GetNoArena();
}
inline void DBReaderProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.name)
}
#if LANG_CXX11
inline void DBReaderProto::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.name)
}
#endif
inline void DBReaderProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.name)
}
inline void DBReaderProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.name)
}
inline ::std::string* DBReaderProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* DBReaderProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.name)
}

// optional string source = 2;
inline bool DBReaderProto::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBReaderProto::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBReaderProto::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBReaderProto::clear_source() {
  source_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& DBReaderProto::source() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.source)
  return source_.GetNoArena();
}
inline void DBReaderProto::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.source)
}
#if LANG_CXX11
inline void DBReaderProto::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.source)
}
#endif
inline void DBReaderProto::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.source)
}
inline void DBReaderProto::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.source)
}
inline ::std::string* DBReaderProto::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.source)
  return source_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* DBReaderProto::release_source() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.source)
  clear_has_source();
  return source_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.source)
}

// optional string db_type = 3;
inline bool DBReaderProto::has_db_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBReaderProto::set_has_db_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBReaderProto::clear_has_db_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBReaderProto::clear_db_type() {
  db_type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_db_type();
}
inline const ::std::string& DBReaderProto::db_type() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.db_type)
  return db_type_.GetNoArena();
}
inline void DBReaderProto::set_db_type(const ::std::string& value) {
  set_has_db_type();
  db_type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.db_type)
}
#if LANG_CXX11
inline void DBReaderProto::set_db_type(::std::string&& value) {
  set_has_db_type();
  db_type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.db_type)
}
#endif
inline void DBReaderProto::set_db_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_db_type();
  db_type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.db_type)
}
inline void DBReaderProto::set_db_type(const char* value, size_t size) {
  set_has_db_type();
  db_type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.db_type)
}
inline ::std::string* DBReaderProto::mutable_db_type() {
  set_has_db_type();
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.db_type)
  return db_type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* DBReaderProto::release_db_type() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.db_type)
  clear_has_db_type();
  return db_type_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_db_type(::std::string* db_type) {
  if (db_type != NULL) {
    set_has_db_type();
  } else {
    clear_has_db_type();
  }
  db_type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), db_type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.db_type)
}

// optional string key = 4;
inline bool DBReaderProto::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBReaderProto::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBReaderProto::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBReaderProto::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& DBReaderProto::key() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.key)
  return key_.GetNoArena();
}
inline void DBReaderProto::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.key)
}
#if LANG_CXX11
inline void DBReaderProto::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.key)
}
#endif
inline void DBReaderProto::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.key)
}
inline void DBReaderProto::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.key)
}
inline ::std::string* DBReaderProto::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.key)
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* DBReaderProto::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.key)
  clear_has_key();
  return key_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::caffe2::ExternalDataProto_SourceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::ExternalDataProto_SourceType>() {
  return ::caffe2::ExternalDataProto_SourceType_descriptor();
}
template <> struct is_proto_enum< ::caffe2::TensorProto_DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::TensorProto_DataType>() {
  return ::caffe2::TensorProto_DataType_descriptor();
}
template <> struct is_proto_enum< ::caffe2::TensorProto_StorageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::TensorProto_StorageType>() {
  return ::caffe2::TensorProto_StorageType_descriptor();
}
template <> struct is_proto_enum< ::caffe2::DeviceTypeProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::DeviceTypeProto>() {
  return ::caffe2::DeviceTypeProto_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_caffe2_2fproto_2fcaffe2_2eproto__INCLUDED
