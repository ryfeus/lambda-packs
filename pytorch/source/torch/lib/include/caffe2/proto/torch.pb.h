// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/torch.proto

#ifndef PROTOBUF_caffe2_2fproto_2ftorch_2eproto__INCLUDED
#define PROTOBUF_caffe2_2fproto_2ftorch_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_caffe2_2fproto_2ftorch_2eproto {
// Internal implementation detail -- do not use these members.
struct CAFFE2_API TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void CAFFE2_API AddDescriptors();
void CAFFE2_API InitDefaultsRecordRefImpl();
void CAFFE2_API InitDefaultsRecordRef();
void CAFFE2_API InitDefaultsTensorDefImpl();
void CAFFE2_API InitDefaultsTensorDef();
void CAFFE2_API InitDefaultsParameterDefImpl();
void CAFFE2_API InitDefaultsParameterDef();
void CAFFE2_API InitDefaultsModuleDefImpl();
void CAFFE2_API InitDefaultsModuleDef();
void CAFFE2_API InitDefaultsModelDefImpl();
void CAFFE2_API InitDefaultsModelDef();
inline void CAFFE2_API InitDefaults() {
  InitDefaultsRecordRef();
  InitDefaultsTensorDef();
  InitDefaultsParameterDef();
  InitDefaultsModuleDef();
  InitDefaultsModelDef();
}
}  // namespace protobuf_caffe2_2fproto_2ftorch_2eproto
namespace torch { const ::std::string& GetEmptyStringAlreadyInited(); 
class ModelDef;
class ModelDefDefaultTypeInternal;
CAFFE2_API extern ModelDefDefaultTypeInternal _ModelDef_default_instance_;
class ModuleDef;
class ModuleDefDefaultTypeInternal;
CAFFE2_API extern ModuleDefDefaultTypeInternal _ModuleDef_default_instance_;
class ParameterDef;
class ParameterDefDefaultTypeInternal;
CAFFE2_API extern ParameterDefDefaultTypeInternal _ParameterDef_default_instance_;
class RecordRef;
class RecordRefDefaultTypeInternal;
CAFFE2_API extern RecordRefDefaultTypeInternal _RecordRef_default_instance_;
class TensorDef;
class TensorDefDefaultTypeInternal;
CAFFE2_API extern TensorDefDefaultTypeInternal _TensorDef_default_instance_;
}  // namespace torch
namespace torch {

enum ProtoVersion {
  PROTO_VERSION_NEWEST = 1
};
CAFFE2_API bool ProtoVersion_IsValid(int value);
const ProtoVersion ProtoVersion_MIN = PROTO_VERSION_NEWEST;
const ProtoVersion ProtoVersion_MAX = PROTO_VERSION_NEWEST;
const int ProtoVersion_ARRAYSIZE = ProtoVersion_MAX + 1;

CAFFE2_API const ::google::protobuf::EnumDescriptor* ProtoVersion_descriptor();
inline const ::std::string& ProtoVersion_Name(ProtoVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtoVersion_descriptor(), value);
}
inline bool ProtoVersion_Parse(
    const ::std::string& name, ProtoVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtoVersion>(
    ProtoVersion_descriptor(), name, value);
}
// ===================================================================

class CAFFE2_API RecordRef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.RecordRef) */ {
 public:
  RecordRef();
  virtual ~RecordRef();

  RecordRef(const RecordRef& from);

  inline RecordRef& operator=(const RecordRef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordRef(RecordRef&& from) noexcept
    : RecordRef() {
    *this = ::std::move(from);
  }

  inline RecordRef& operator=(RecordRef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordRef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordRef* internal_default_instance() {
    return reinterpret_cast<const RecordRef*>(
               &_RecordRef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    0;

  void Swap(RecordRef* other);
  friend void swap(RecordRef& a, RecordRef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordRef* New() const PROTOBUF_FINAL { return New(NULL); }

  RecordRef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecordRef& from);
  void MergeFrom(const RecordRef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecordRef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:torch.RecordRef)
 private:
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsRecordRefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API TensorDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.TensorDef) */ {
 public:
  TensorDef();
  virtual ~TensorDef();

  TensorDef(const TensorDef& from);

  inline TensorDef& operator=(const TensorDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorDef(TensorDef&& from) noexcept
    : TensorDef() {
    *this = ::std::move(from);
  }

  inline TensorDef& operator=(TensorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorDef* internal_default_instance() {
    return reinterpret_cast<const TensorDef*>(
               &_TensorDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    1;

  void Swap(TensorDef* other);
  friend void swap(TensorDef& a, TensorDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorDef* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorDef& from);
  void MergeFrom(const TensorDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // repeated int64 strides = 3;
  int strides_size() const;
  void clear_strides();
  static const int kStridesFieldNumber = 3;
  ::google::protobuf::int64 strides(int index) const;
  void set_strides(int index, ::google::protobuf::int64 value);
  void add_strides(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      strides() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_strides();

  // optional string device = 7;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 7;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // optional .torch.RecordRef data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::torch::RecordRef& data() const;
  ::torch::RecordRef* release_data();
  ::torch::RecordRef* mutable_data();
  void set_allocated_data(::torch::RecordRef* data);

  // optional int64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // optional bool requires_grad = 4;
  bool has_requires_grad() const;
  void clear_requires_grad();
  static const int kRequiresGradFieldNumber = 4;
  bool requires_grad() const;
  void set_requires_grad(bool value);

  // optional .caffe2.TensorProto.DataType data_type = 5;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 5;
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);

  // @@protoc_insertion_point(class_scope:torch.TensorDef)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_requires_grad();
  void clear_has_requires_grad();
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_data();
  void clear_has_data();
  void set_has_device();
  void clear_has_device();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > strides_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::torch::RecordRef* data_;
  ::google::protobuf::int64 offset_;
  bool requires_grad_;
  int data_type_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsTensorDefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API ParameterDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.ParameterDef) */ {
 public:
  ParameterDef();
  virtual ~ParameterDef();

  ParameterDef(const ParameterDef& from);

  inline ParameterDef& operator=(const ParameterDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParameterDef(ParameterDef&& from) noexcept
    : ParameterDef() {
    *this = ::std::move(from);
  }

  inline ParameterDef& operator=(ParameterDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParameterDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParameterDef* internal_default_instance() {
    return reinterpret_cast<const ParameterDef*>(
               &_ParameterDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    2;

  void Swap(ParameterDef* other);
  friend void swap(ParameterDef& a, ParameterDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParameterDef* New() const PROTOBUF_FINAL { return New(NULL); }

  ParameterDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParameterDef& from);
  void MergeFrom(const ParameterDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParameterDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int64 tensor_id = 2;
  bool has_tensor_id() const;
  void clear_tensor_id();
  static const int kTensorIdFieldNumber = 2;
  ::google::protobuf::int64 tensor_id() const;
  void set_tensor_id(::google::protobuf::int64 value);

  // optional bool is_buffer = 1;
  bool has_is_buffer() const;
  void clear_is_buffer();
  static const int kIsBufferFieldNumber = 1;
  bool is_buffer() const;
  void set_is_buffer(bool value);

  // @@protoc_insertion_point(class_scope:torch.ParameterDef)
 private:
  void set_has_is_buffer();
  void clear_has_is_buffer();
  void set_has_tensor_id();
  void clear_has_tensor_id();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 tensor_id_;
  bool is_buffer_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsParameterDefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API ModuleDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.ModuleDef) */ {
 public:
  ModuleDef();
  virtual ~ModuleDef();

  ModuleDef(const ModuleDef& from);

  inline ModuleDef& operator=(const ModuleDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleDef(ModuleDef&& from) noexcept
    : ModuleDef() {
    *this = ::std::move(from);
  }

  inline ModuleDef& operator=(ModuleDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleDef* internal_default_instance() {
    return reinterpret_cast<const ModuleDef*>(
               &_ModuleDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    3;

  void Swap(ModuleDef* other);
  friend void swap(ModuleDef& a, ModuleDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleDef* New() const PROTOBUF_FINAL { return New(NULL); }

  ModuleDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModuleDef& from);
  void MergeFrom(const ModuleDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModuleDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .torch.ModuleDef submodules = 1;
  int submodules_size() const;
  void clear_submodules();
  static const int kSubmodulesFieldNumber = 1;
  const ::torch::ModuleDef& submodules(int index) const;
  ::torch::ModuleDef* mutable_submodules(int index);
  ::torch::ModuleDef* add_submodules();
  ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >*
      mutable_submodules();
  const ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >&
      submodules() const;

  // repeated .caffe2.NetDef caffe2_nets = 3;
  int caffe2_nets_size() const;
  void clear_caffe2_nets();
  static const int kCaffe2NetsFieldNumber = 3;
  const ::caffe2::NetDef& caffe2_nets(int index) const;
  ::caffe2::NetDef* mutable_caffe2_nets(int index);
  ::caffe2::NetDef* add_caffe2_nets();
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >*
      mutable_caffe2_nets();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >&
      caffe2_nets() const;

  // repeated .torch.ParameterDef parameters = 6;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 6;
  const ::torch::ParameterDef& parameters(int index) const;
  ::torch::ParameterDef* mutable_parameters(int index);
  ::torch::ParameterDef* add_parameters();
  ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >*
      mutable_parameters();
  const ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >&
      parameters() const;

  // optional string name = 7;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 7;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .torch.RecordRef torchscript_arena = 2;
  bool has_torchscript_arena() const;
  void clear_torchscript_arena();
  static const int kTorchscriptArenaFieldNumber = 2;
  const ::torch::RecordRef& torchscript_arena() const;
  ::torch::RecordRef* release_torchscript_arena();
  ::torch::RecordRef* mutable_torchscript_arena();
  void set_allocated_torchscript_arena(::torch::RecordRef* torchscript_arena);

  // optional .torch.RecordRef pickle_arena = 4;
  bool has_pickle_arena() const;
  void clear_pickle_arena();
  static const int kPickleArenaFieldNumber = 4;
  const ::torch::RecordRef& pickle_arena() const;
  ::torch::RecordRef* release_pickle_arena();
  ::torch::RecordRef* mutable_pickle_arena();
  void set_allocated_pickle_arena(::torch::RecordRef* pickle_arena);

  // optional .torch.RecordRef cpp_arena = 5;
  bool has_cpp_arena() const;
  void clear_cpp_arena();
  static const int kCppArenaFieldNumber = 5;
  const ::torch::RecordRef& cpp_arena() const;
  ::torch::RecordRef* release_cpp_arena();
  ::torch::RecordRef* mutable_cpp_arena();
  void set_allocated_cpp_arena(::torch::RecordRef* cpp_arena);

  // optional bool optimize = 8;
  bool has_optimize() const;
  void clear_optimize();
  static const int kOptimizeFieldNumber = 8;
  bool optimize() const;
  void set_optimize(bool value);

  // @@protoc_insertion_point(class_scope:torch.ModuleDef)
 private:
  void set_has_torchscript_arena();
  void clear_has_torchscript_arena();
  void set_has_pickle_arena();
  void clear_has_pickle_arena();
  void set_has_cpp_arena();
  void clear_has_cpp_arena();
  void set_has_name();
  void clear_has_name();
  void set_has_optimize();
  void clear_has_optimize();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef > submodules_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef > caffe2_nets_;
  ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef > parameters_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::torch::RecordRef* torchscript_arena_;
  ::torch::RecordRef* pickle_arena_;
  ::torch::RecordRef* cpp_arena_;
  bool optimize_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsModuleDefImpl();
};
// -------------------------------------------------------------------

class CAFFE2_API ModelDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:torch.ModelDef) */ {
 public:
  ModelDef();
  virtual ~ModelDef();

  ModelDef(const ModelDef& from);

  inline ModelDef& operator=(const ModelDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelDef(ModelDef&& from) noexcept
    : ModelDef() {
    *this = ::std::move(from);
  }

  inline ModelDef& operator=(ModelDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelDef* internal_default_instance() {
    return reinterpret_cast<const ModelDef*>(
               &_ModelDef_default_instance_);
  }
  static  int const kIndexInFileMessages =
    4;

  void Swap(ModelDef* other);
  friend void swap(ModelDef& a, ModelDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelDef* New() const PROTOBUF_FINAL { return New(NULL); }

  ModelDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModelDef& from);
  void MergeFrom(const ModelDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModelDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .torch.TensorDef tensors = 5;
  int tensors_size() const;
  void clear_tensors();
  static const int kTensorsFieldNumber = 5;
  const ::torch::TensorDef& tensors(int index) const;
  ::torch::TensorDef* mutable_tensors(int index);
  ::torch::TensorDef* add_tensors();
  ::google::protobuf::RepeatedPtrField< ::torch::TensorDef >*
      mutable_tensors();
  const ::google::protobuf::RepeatedPtrField< ::torch::TensorDef >&
      tensors() const;

  // optional string producer_name = 3;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 3;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_producer_name(::std::string&& value);
  #endif
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional string producer_version = 4;
  bool has_producer_version() const;
  void clear_producer_version();
  static const int kProducerVersionFieldNumber = 4;
  const ::std::string& producer_version() const;
  void set_producer_version(const ::std::string& value);
  #if LANG_CXX11
  void set_producer_version(::std::string&& value);
  #endif
  void set_producer_version(const char* value);
  void set_producer_version(const char* value, size_t size);
  ::std::string* mutable_producer_version();
  ::std::string* release_producer_version();
  void set_allocated_producer_version(::std::string* producer_version);

  // optional .torch.ModuleDef main_module = 2;
  bool has_main_module() const;
  void clear_main_module();
  static const int kMainModuleFieldNumber = 2;
  const ::torch::ModuleDef& main_module() const;
  ::torch::ModuleDef* release_main_module();
  ::torch::ModuleDef* mutable_main_module();
  void set_allocated_main_module(::torch::ModuleDef* main_module);

  // optional int64 proto_version = 1;
  bool has_proto_version() const;
  void clear_proto_version();
  static const int kProtoVersionFieldNumber = 1;
  ::google::protobuf::int64 proto_version() const;
  void set_proto_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:torch.ModelDef)
 private:
  void set_has_proto_version();
  void clear_has_proto_version();
  void set_has_main_module();
  void clear_has_main_module();
  void set_has_producer_name();
  void clear_has_producer_name();
  void set_has_producer_version();
  void clear_has_producer_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::torch::TensorDef > tensors_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::internal::ArenaStringPtr producer_version_;
  ::torch::ModuleDef* main_module_;
  ::google::protobuf::int64 proto_version_;
  friend struct ::protobuf_caffe2_2fproto_2ftorch_2eproto::TableStruct;
  friend void ::protobuf_caffe2_2fproto_2ftorch_2eproto::InitDefaultsModelDefImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecordRef

// optional string key = 1;
inline bool RecordRef::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordRef::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordRef::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordRef::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& RecordRef::key() const {
  // @@protoc_insertion_point(field_get:torch.RecordRef.key)
  return key_.GetNoArena();
}
inline void RecordRef::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.RecordRef.key)
}
#if LANG_CXX11
inline void RecordRef::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.RecordRef.key)
}
#endif
inline void RecordRef::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.RecordRef.key)
}
inline void RecordRef::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.RecordRef.key)
}
inline ::std::string* RecordRef::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:torch.RecordRef.key)
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* RecordRef::release_key() {
  // @@protoc_insertion_point(field_release:torch.RecordRef.key)
  clear_has_key();
  return key_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void RecordRef::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:torch.RecordRef.key)
}

// -------------------------------------------------------------------

// TensorDef

// repeated int64 dims = 1;
inline int TensorDef::dims_size() const {
  return dims_.size();
}
inline void TensorDef::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 TensorDef::dims(int index) const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.dims)
  return dims_.Get(index);
}
inline void TensorDef::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.dims)
}
inline void TensorDef::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:torch.TensorDef.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TensorDef::dims() const {
  // @@protoc_insertion_point(field_list:torch.TensorDef.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TensorDef::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:torch.TensorDef.dims)
  return &dims_;
}

// optional int64 offset = 2;
inline bool TensorDef::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TensorDef::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TensorDef::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TensorDef::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 TensorDef::offset() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.offset)
  return offset_;
}
inline void TensorDef::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:torch.TensorDef.offset)
}

// repeated int64 strides = 3;
inline int TensorDef::strides_size() const {
  return strides_.size();
}
inline void TensorDef::clear_strides() {
  strides_.Clear();
}
inline ::google::protobuf::int64 TensorDef::strides(int index) const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.strides)
  return strides_.Get(index);
}
inline void TensorDef::set_strides(int index, ::google::protobuf::int64 value) {
  strides_.Set(index, value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.strides)
}
inline void TensorDef::add_strides(::google::protobuf::int64 value) {
  strides_.Add(value);
  // @@protoc_insertion_point(field_add:torch.TensorDef.strides)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TensorDef::strides() const {
  // @@protoc_insertion_point(field_list:torch.TensorDef.strides)
  return strides_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TensorDef::mutable_strides() {
  // @@protoc_insertion_point(field_mutable_list:torch.TensorDef.strides)
  return &strides_;
}

// optional bool requires_grad = 4;
inline bool TensorDef::has_requires_grad() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TensorDef::set_has_requires_grad() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TensorDef::clear_has_requires_grad() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TensorDef::clear_requires_grad() {
  requires_grad_ = false;
  clear_has_requires_grad();
}
inline bool TensorDef::requires_grad() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.requires_grad)
  return requires_grad_;
}
inline void TensorDef::set_requires_grad(bool value) {
  set_has_requires_grad();
  requires_grad_ = value;
  // @@protoc_insertion_point(field_set:torch.TensorDef.requires_grad)
}

// optional .caffe2.TensorProto.DataType data_type = 5;
inline bool TensorDef::has_data_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TensorDef::set_has_data_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TensorDef::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TensorDef::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::caffe2::TensorProto_DataType TensorDef::data_type() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.data_type)
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline void TensorDef::set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:torch.TensorDef.data_type)
}

// optional .torch.RecordRef data = 6;
inline bool TensorDef::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TensorDef::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TensorDef::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TensorDef::clear_data() {
  if (data_ != NULL) data_->Clear();
  clear_has_data();
}
inline const ::torch::RecordRef& TensorDef::data() const {
  const ::torch::RecordRef* p = data_;
  // @@protoc_insertion_point(field_get:torch.TensorDef.data)
  return p != NULL ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline ::torch::RecordRef* TensorDef::release_data() {
  // @@protoc_insertion_point(field_release:torch.TensorDef.data)
  clear_has_data();
  ::torch::RecordRef* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::torch::RecordRef* TensorDef::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    data_ = new ::torch::RecordRef;
  }
  // @@protoc_insertion_point(field_mutable:torch.TensorDef.data)
  return data_;
}
inline void TensorDef::set_allocated_data(::torch::RecordRef* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    set_has_data();
  } else {
    clear_has_data();
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:torch.TensorDef.data)
}

// optional string device = 7;
inline bool TensorDef::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TensorDef::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TensorDef::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TensorDef::clear_device() {
  device_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_device();
}
inline const ::std::string& TensorDef::device() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.device)
  return device_.GetNoArena();
}
inline void TensorDef::set_device(const ::std::string& value) {
  set_has_device();
  device_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.device)
}
#if LANG_CXX11
inline void TensorDef::set_device(::std::string&& value) {
  set_has_device();
  device_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.TensorDef.device)
}
#endif
inline void TensorDef::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device();
  device_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.TensorDef.device)
}
inline void TensorDef::set_device(const char* value, size_t size) {
  set_has_device();
  device_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.TensorDef.device)
}
inline ::std::string* TensorDef::mutable_device() {
  set_has_device();
  // @@protoc_insertion_point(field_mutable:torch.TensorDef.device)
  return device_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorDef::release_device() {
  // @@protoc_insertion_point(field_release:torch.TensorDef.device)
  clear_has_device();
  return device_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorDef::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    set_has_device();
  } else {
    clear_has_device();
  }
  device_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:torch.TensorDef.device)
}

// -------------------------------------------------------------------

// ParameterDef

// optional bool is_buffer = 1;
inline bool ParameterDef::has_is_buffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParameterDef::set_has_is_buffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParameterDef::clear_has_is_buffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParameterDef::clear_is_buffer() {
  is_buffer_ = false;
  clear_has_is_buffer();
}
inline bool ParameterDef::is_buffer() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.is_buffer)
  return is_buffer_;
}
inline void ParameterDef::set_is_buffer(bool value) {
  set_has_is_buffer();
  is_buffer_ = value;
  // @@protoc_insertion_point(field_set:torch.ParameterDef.is_buffer)
}

// optional int64 tensor_id = 2;
inline bool ParameterDef::has_tensor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParameterDef::set_has_tensor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParameterDef::clear_has_tensor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParameterDef::clear_tensor_id() {
  tensor_id_ = GOOGLE_LONGLONG(0);
  clear_has_tensor_id();
}
inline ::google::protobuf::int64 ParameterDef::tensor_id() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.tensor_id)
  return tensor_id_;
}
inline void ParameterDef::set_tensor_id(::google::protobuf::int64 value) {
  set_has_tensor_id();
  tensor_id_ = value;
  // @@protoc_insertion_point(field_set:torch.ParameterDef.tensor_id)
}

// optional string name = 3;
inline bool ParameterDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParameterDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParameterDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParameterDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ParameterDef::name() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.name)
  return name_.GetNoArena();
}
inline void ParameterDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ParameterDef.name)
}
#if LANG_CXX11
inline void ParameterDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ParameterDef.name)
}
#endif
inline void ParameterDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ParameterDef.name)
}
inline void ParameterDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ParameterDef.name)
}
inline ::std::string* ParameterDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:torch.ParameterDef.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ParameterDef::release_name() {
  // @@protoc_insertion_point(field_release:torch.ParameterDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ParameterDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:torch.ParameterDef.name)
}

// -------------------------------------------------------------------

// ModuleDef

// repeated .torch.ModuleDef submodules = 1;
inline int ModuleDef::submodules_size() const {
  return submodules_.size();
}
inline void ModuleDef::clear_submodules() {
  submodules_.Clear();
}
inline const ::torch::ModuleDef& ModuleDef::submodules(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.submodules)
  return submodules_.Get(index);
}
inline ::torch::ModuleDef* ModuleDef::mutable_submodules(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.submodules)
  return submodules_.Mutable(index);
}
inline ::torch::ModuleDef* ModuleDef::add_submodules() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.submodules)
  return submodules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >*
ModuleDef::mutable_submodules() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.submodules)
  return &submodules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::torch::ModuleDef >&
ModuleDef::submodules() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.submodules)
  return submodules_;
}

// optional .torch.RecordRef torchscript_arena = 2;
inline bool ModuleDef::has_torchscript_arena() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleDef::set_has_torchscript_arena() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleDef::clear_has_torchscript_arena() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleDef::clear_torchscript_arena() {
  if (torchscript_arena_ != NULL) torchscript_arena_->Clear();
  clear_has_torchscript_arena();
}
inline const ::torch::RecordRef& ModuleDef::torchscript_arena() const {
  const ::torch::RecordRef* p = torchscript_arena_;
  // @@protoc_insertion_point(field_get:torch.ModuleDef.torchscript_arena)
  return p != NULL ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline ::torch::RecordRef* ModuleDef::release_torchscript_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.torchscript_arena)
  clear_has_torchscript_arena();
  ::torch::RecordRef* temp = torchscript_arena_;
  torchscript_arena_ = NULL;
  return temp;
}
inline ::torch::RecordRef* ModuleDef::mutable_torchscript_arena() {
  set_has_torchscript_arena();
  if (torchscript_arena_ == NULL) {
    torchscript_arena_ = new ::torch::RecordRef;
  }
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.torchscript_arena)
  return torchscript_arena_;
}
inline void ModuleDef::set_allocated_torchscript_arena(::torch::RecordRef* torchscript_arena) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete torchscript_arena_;
  }
  if (torchscript_arena) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      torchscript_arena = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, torchscript_arena, submessage_arena);
    }
    set_has_torchscript_arena();
  } else {
    clear_has_torchscript_arena();
  }
  torchscript_arena_ = torchscript_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.torchscript_arena)
}

// repeated .caffe2.NetDef caffe2_nets = 3;
inline int ModuleDef::caffe2_nets_size() const {
  return caffe2_nets_.size();
}
inline const ::caffe2::NetDef& ModuleDef::caffe2_nets(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.caffe2_nets)
  return caffe2_nets_.Get(index);
}
inline ::caffe2::NetDef* ModuleDef::mutable_caffe2_nets(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.caffe2_nets)
  return caffe2_nets_.Mutable(index);
}
inline ::caffe2::NetDef* ModuleDef::add_caffe2_nets() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.caffe2_nets)
  return caffe2_nets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >*
ModuleDef::mutable_caffe2_nets() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.caffe2_nets)
  return &caffe2_nets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::NetDef >&
ModuleDef::caffe2_nets() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.caffe2_nets)
  return caffe2_nets_;
}

// optional .torch.RecordRef pickle_arena = 4;
inline bool ModuleDef::has_pickle_arena() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModuleDef::set_has_pickle_arena() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModuleDef::clear_has_pickle_arena() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModuleDef::clear_pickle_arena() {
  if (pickle_arena_ != NULL) pickle_arena_->Clear();
  clear_has_pickle_arena();
}
inline const ::torch::RecordRef& ModuleDef::pickle_arena() const {
  const ::torch::RecordRef* p = pickle_arena_;
  // @@protoc_insertion_point(field_get:torch.ModuleDef.pickle_arena)
  return p != NULL ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline ::torch::RecordRef* ModuleDef::release_pickle_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.pickle_arena)
  clear_has_pickle_arena();
  ::torch::RecordRef* temp = pickle_arena_;
  pickle_arena_ = NULL;
  return temp;
}
inline ::torch::RecordRef* ModuleDef::mutable_pickle_arena() {
  set_has_pickle_arena();
  if (pickle_arena_ == NULL) {
    pickle_arena_ = new ::torch::RecordRef;
  }
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.pickle_arena)
  return pickle_arena_;
}
inline void ModuleDef::set_allocated_pickle_arena(::torch::RecordRef* pickle_arena) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pickle_arena_;
  }
  if (pickle_arena) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pickle_arena = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pickle_arena, submessage_arena);
    }
    set_has_pickle_arena();
  } else {
    clear_has_pickle_arena();
  }
  pickle_arena_ = pickle_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.pickle_arena)
}

// optional .torch.RecordRef cpp_arena = 5;
inline bool ModuleDef::has_cpp_arena() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModuleDef::set_has_cpp_arena() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModuleDef::clear_has_cpp_arena() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModuleDef::clear_cpp_arena() {
  if (cpp_arena_ != NULL) cpp_arena_->Clear();
  clear_has_cpp_arena();
}
inline const ::torch::RecordRef& ModuleDef::cpp_arena() const {
  const ::torch::RecordRef* p = cpp_arena_;
  // @@protoc_insertion_point(field_get:torch.ModuleDef.cpp_arena)
  return p != NULL ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline ::torch::RecordRef* ModuleDef::release_cpp_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.cpp_arena)
  clear_has_cpp_arena();
  ::torch::RecordRef* temp = cpp_arena_;
  cpp_arena_ = NULL;
  return temp;
}
inline ::torch::RecordRef* ModuleDef::mutable_cpp_arena() {
  set_has_cpp_arena();
  if (cpp_arena_ == NULL) {
    cpp_arena_ = new ::torch::RecordRef;
  }
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.cpp_arena)
  return cpp_arena_;
}
inline void ModuleDef::set_allocated_cpp_arena(::torch::RecordRef* cpp_arena) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cpp_arena_;
  }
  if (cpp_arena) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cpp_arena = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cpp_arena, submessage_arena);
    }
    set_has_cpp_arena();
  } else {
    clear_has_cpp_arena();
  }
  cpp_arena_ = cpp_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.cpp_arena)
}

// repeated .torch.ParameterDef parameters = 6;
inline int ModuleDef::parameters_size() const {
  return parameters_.size();
}
inline void ModuleDef::clear_parameters() {
  parameters_.Clear();
}
inline const ::torch::ParameterDef& ModuleDef::parameters(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.parameters)
  return parameters_.Get(index);
}
inline ::torch::ParameterDef* ModuleDef::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.parameters)
  return parameters_.Mutable(index);
}
inline ::torch::ParameterDef* ModuleDef::add_parameters() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.parameters)
  return parameters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >*
ModuleDef::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.parameters)
  return &parameters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::torch::ParameterDef >&
ModuleDef::parameters() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.parameters)
  return parameters_;
}

// optional string name = 7;
inline bool ModuleDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ModuleDef::name() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.name)
  return name_.GetNoArena();
}
inline void ModuleDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModuleDef.name)
}
#if LANG_CXX11
inline void ModuleDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModuleDef.name)
}
#endif
inline void ModuleDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModuleDef.name)
}
inline void ModuleDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModuleDef.name)
}
inline ::std::string* ModuleDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.name)
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleDef::release_name() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModuleDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.name)
}

// optional bool optimize = 8;
inline bool ModuleDef::has_optimize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModuleDef::set_has_optimize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModuleDef::clear_has_optimize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModuleDef::clear_optimize() {
  optimize_ = false;
  clear_has_optimize();
}
inline bool ModuleDef::optimize() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.optimize)
  return optimize_;
}
inline void ModuleDef::set_optimize(bool value) {
  set_has_optimize();
  optimize_ = value;
  // @@protoc_insertion_point(field_set:torch.ModuleDef.optimize)
}

// -------------------------------------------------------------------

// ModelDef

// optional int64 proto_version = 1;
inline bool ModelDef::has_proto_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelDef::set_has_proto_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelDef::clear_has_proto_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelDef::clear_proto_version() {
  proto_version_ = GOOGLE_LONGLONG(0);
  clear_has_proto_version();
}
inline ::google::protobuf::int64 ModelDef::proto_version() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.proto_version)
  return proto_version_;
}
inline void ModelDef::set_proto_version(::google::protobuf::int64 value) {
  set_has_proto_version();
  proto_version_ = value;
  // @@protoc_insertion_point(field_set:torch.ModelDef.proto_version)
}

// optional .torch.ModuleDef main_module = 2;
inline bool ModelDef::has_main_module() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelDef::set_has_main_module() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelDef::clear_has_main_module() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelDef::clear_main_module() {
  if (main_module_ != NULL) main_module_->Clear();
  clear_has_main_module();
}
inline const ::torch::ModuleDef& ModelDef::main_module() const {
  const ::torch::ModuleDef* p = main_module_;
  // @@protoc_insertion_point(field_get:torch.ModelDef.main_module)
  return p != NULL ? *p : *reinterpret_cast<const ::torch::ModuleDef*>(
      &::torch::_ModuleDef_default_instance_);
}
inline ::torch::ModuleDef* ModelDef::release_main_module() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.main_module)
  clear_has_main_module();
  ::torch::ModuleDef* temp = main_module_;
  main_module_ = NULL;
  return temp;
}
inline ::torch::ModuleDef* ModelDef::mutable_main_module() {
  set_has_main_module();
  if (main_module_ == NULL) {
    main_module_ = new ::torch::ModuleDef;
  }
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.main_module)
  return main_module_;
}
inline void ModelDef::set_allocated_main_module(::torch::ModuleDef* main_module) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete main_module_;
  }
  if (main_module) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      main_module = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, main_module, submessage_arena);
    }
    set_has_main_module();
  } else {
    clear_has_main_module();
  }
  main_module_ = main_module;
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.main_module)
}

// optional string producer_name = 3;
inline bool ModelDef::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelDef::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelDef::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelDef::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& ModelDef::producer_name() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.producer_name)
  return producer_name_.GetNoArena();
}
inline void ModelDef::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.producer_name)
}
#if LANG_CXX11
inline void ModelDef::set_producer_name(::std::string&& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModelDef.producer_name)
}
#endif
inline void ModelDef::set_producer_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_producer_name();
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModelDef.producer_name)
}
inline void ModelDef::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModelDef.producer_name)
}
inline ::std::string* ModelDef::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.producer_name)
  return producer_name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelDef::release_producer_name() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelDef::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.producer_name)
}

// optional string producer_version = 4;
inline bool ModelDef::has_producer_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelDef::set_has_producer_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelDef::clear_has_producer_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelDef::clear_producer_version() {
  producer_version_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  clear_has_producer_version();
}
inline const ::std::string& ModelDef::producer_version() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.producer_version)
  return producer_version_.GetNoArena();
}
inline void ModelDef::set_producer_version(const ::std::string& value) {
  set_has_producer_version();
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.producer_version)
}
#if LANG_CXX11
inline void ModelDef::set_producer_version(::std::string&& value) {
  set_has_producer_version();
  producer_version_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModelDef.producer_version)
}
#endif
inline void ModelDef::set_producer_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_producer_version();
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModelDef.producer_version)
}
inline void ModelDef::set_producer_version(const char* value, size_t size) {
  set_has_producer_version();
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModelDef.producer_version)
}
inline ::std::string* ModelDef::mutable_producer_version() {
  set_has_producer_version();
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.producer_version)
  return producer_version_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelDef::release_producer_version() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.producer_version)
  clear_has_producer_version();
  return producer_version_.ReleaseNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelDef::set_allocated_producer_version(::std::string* producer_version) {
  if (producer_version != NULL) {
    set_has_producer_version();
  } else {
    clear_has_producer_version();
  }
  producer_version_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), producer_version);
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.producer_version)
}

// repeated .torch.TensorDef tensors = 5;
inline int ModelDef::tensors_size() const {
  return tensors_.size();
}
inline void ModelDef::clear_tensors() {
  tensors_.Clear();
}
inline const ::torch::TensorDef& ModelDef::tensors(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.tensors)
  return tensors_.Get(index);
}
inline ::torch::TensorDef* ModelDef::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.tensors)
  return tensors_.Mutable(index);
}
inline ::torch::TensorDef* ModelDef::add_tensors() {
  // @@protoc_insertion_point(field_add:torch.ModelDef.tensors)
  return tensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::torch::TensorDef >*
ModelDef::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModelDef.tensors)
  return &tensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::torch::TensorDef >&
ModelDef::tensors() const {
  // @@protoc_insertion_point(field_list:torch.ModelDef.tensors)
  return tensors_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace torch

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::torch::ProtoVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::torch::ProtoVersion>() {
  return ::torch::ProtoVersion_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_caffe2_2fproto_2ftorch_2eproto__INCLUDED
